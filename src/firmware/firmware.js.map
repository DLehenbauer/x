{"version":3,"sources":["C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten\\avr\\mocks.cpp","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten\\bindings.cpp","C:\\emsdk\\emscripten\\1.37.33\\system\\include\\emscripten/bind.h","C:\\emsdk\\emscripten\\1.37.33\\system\\include\\emscripten/wire.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../lerp.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../synth.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../midisynth.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../instruments.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\main.cpp","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/ssd1306.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/midisynth.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\synth.cpp","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/drivers/dac/ltc16xx.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/drivers/dac/../pin.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/drivers/dac/../spi.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/synth.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\instruments.cpp","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/instruments.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\midi.cpp","C:\\emsdk\\emscripten\\1.37.33\\system\\lib\\embind\\bind.cpp","C:\\emsdk\\emscripten\\1.37.33\\system\\include\\libcxx\\typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAIA;;;;;;;;;;;AC/IA;AACA;;;AACA;;;;;;;;;;;AAGA;;;AACA;;;;;;;;;AAGA;;AAEA;;;;;;;;;;ACmDA;AAAA;AAAA;AAAA;AAAA;ACjDA;;;;;;;;;;AD+EA;AAAA;AAAA;AAAA;AAAA;ACnFA;;;;;;;;AH0IA;AACA;AAAA;;;;;;;;;;;AAOA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAA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AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AhBMA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAoCA;AAAA;;;;;AgBrBA;;;;;AhBfA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAAA;;;;;AAAA;;;;;;;;AgBzBA;;;ACmHA;AAAA;ADnHA;AAAA","file":"C:/gh/my/x/src/firmware/firmware.js","sourcesContent":["/*\n * pgmspace.cpp\n *\n * Created: 2/10/2018 6:39:53 PM\n *  Author: danlehen\n */ \n\n#include \"common.h\"\n#include \"pgmspace.h\"\n\nuint8_t OCR2A;\nuint8_t SPCR;\nuint8_t TCCR2A;\nuint8_t TCCR2B;\nuint8_t UBRR0H;\nuint8_t UBRR0L;\nuint8_t UCSR0B;\nuint8_t UCSR0C;\n\nuint8_t PORTB;\nuint8_t SPDR;\nuint8_t SPSR = 1 << SPIF;\nuint8_t TIMSK2;\n\nvoid cli() {}\nvoid sei() {}\n\nuint8_t pgm_read_byte(const volatile void* ptr) { return *(reinterpret_cast<const volatile uint8_t*>(ptr)); }\nuint16_t pgm_read_word(const volatile void* ptr) { return *(reinterpret_cast<const volatile uint16_t*>(ptr)); }\n","#include \"../lerp.h\"\r#include \"../synth.h\"\r#include \"../midi.h\"\r#include \"../midisynth.h\"\r#include \"../instruments.h\"\r\r#include <emscripten/bind.h>\r\r\nusing namespace emscripten;\r\r\nextern uint8_t OCR2A;\r\nextern MidiSynth synth;\r\n\r\nstatic MidiSynth* getSynth() { return &synth; }\r\nstatic double getSampleRate() { return Synth::sampleRate; }\r\n\r\nEMSCRIPTEN_BINDINGS(firmware) {\r\tfunction(\"midi_decode_byte\", &midi_decode_byte);\r\tfunction(\"getPercussionNotes\", &Instruments::getPercussionNotes);\r\n\tfunction(\"getWavetable\", &Instruments::getWavetable);\r\n\tfunction(\"getLerpStages\", &Instruments::getLerpStages);\r\n\tfunction(\"getLerpPrograms\", &Instruments::getLerpPrograms);\r\n\tfunction(\"getInstruments\", &Instruments::getInstruments);\r\n\t\r\n\tvalue_object<HeapRegion<int8_t>>(\"I8s\")\r\n\t\t.field(\"start\", &HeapRegion<int8_t>::start)\r\n\t\t.field(\"end\", &HeapRegion<int8_t>::end)\r\n\t\t.field(\"itemSize\", &HeapRegion<int8_t>::itemSize);\r\n\r\n\tvalue_object<HeapRegion<uint8_t>>(\"U8s\")\r\n\t\t.field(\"start\", &HeapRegion<uint8_t>::start)\r\n\t\t.field(\"end\", &HeapRegion<uint8_t>::end)\r\n\t\t.field(\"itemSize\", &HeapRegion<uint8_t>::itemSize);\r\n\r\n\tvalue_object<HeapRegion<LerpStage>>(\"LerpStages\")\r\n\t\t.field(\"start\", &HeapRegion<LerpStage>::start)\r\n\t\t.field(\"end\", &HeapRegion<LerpStage>::end)\r\n\t\t.field(\"itemSize\", &HeapRegion<LerpStage>::itemSize);\r\n\r\n\tvalue_object<HeapRegion<LerpProgram>>(\"LerpPrograms\")\r\n\t\t.field(\"start\", &HeapRegion<LerpProgram>::start)\r\n\t\t.field(\"end\", &HeapRegion<LerpProgram>::end)\r\n\t\t.field(\"itemSize\", &HeapRegion<LerpProgram>::itemSize);\r\n\r\n\tvalue_object<HeapRegion<Instrument>>(\"Instruments\")\r\n\t\t.field(\"start\", &HeapRegion<Instrument>::start)\r\n\t\t.field(\"end\", &HeapRegion<Instrument>::end)\r\n\t\t.field(\"itemSize\", &HeapRegion<Instrument>::itemSize);\r\n\t\r\n\tfunction(\"getSampleRate\", &getSampleRate);\r\n\tfunction(\"getSynth\", &getSynth, allow_raw_pointer<ret_val>());\r\n\tclass_<LerpStage>(\"LerpStage\");\r\tclass_<LerpProgram>(\"LerpProgram\");\r\tclass_<Instrument>(\"Instrument\");\r\tclass_<Lerp>(\"Lerp\")\r\t\t.constructor<>()\r\t\t.function(\"sample\", &Lerp::sampleEm)\r\t\t.function(\"start\", &Lerp::startEm)\r\t\t.function(\"stop\", &Lerp::stopEm)\r\t\t.function(\"getStageIndex\", &Lerp::getStageIndex);\r\tclass_<Synth>(\"Synth\")\r\t\t.constructor<>()\r\n\t\t.function(\"sample\", &Synth::sample)\r\n\t\t.function(\"noteOn\", &Synth::noteOnEm)\r\n\t\t.function(\"noteOff\", &Synth::noteOff);\r\n\tclass_<MidiSynth, base<Synth>>(\"MidiSynth\")\r\t\t.constructor<>()\r\t\t.function(\"midiNoteOn\", &MidiSynth::midiNoteOn)\r\t\t.function(\"midiNoteOff\", &MidiSynth::midiNoteOff)\r\t\t.function(\"midiProgramChange\", &MidiSynth::midiProgramChange)\r\t\t.function(\"midiPitchBend\", &MidiSynth::midiPitchBend);\r\n}","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/bind.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void* GenericFunction;\n        typedef void (*VoidFunctionPtr)(void);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            void _embind_register_class_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID fieldType,\n                const void* fieldContext,\n                const char* getterSignature,\n                GenericFunction getter,\n                const char* setterSignature,\n                GenericFunction setter);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                uintptr_t value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        template<typename FieldType>\n        struct GlobalAccess {\n            typedef internal::BindingType<FieldType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n\n            static WireType get(FieldType* context) {\n                return MemberBinding::toWireType(*context);\n            }\n\n            static void set(FieldType* context, WireType value) {\n                *context = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename InstanceType, typename ElementType, int N>\n        value_object& field(const char* fieldName, ElementType (InstanceType::*field)[N]) {\n            using namespace internal;\n\n            typedef std::array<ElementType, N> FieldType;\n            static_assert(sizeof(FieldType) == sizeof(ElementType[N]));\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast   = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, const FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            auto setter = &GlobalAccess<FieldType>::set;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        uintptr_t asGenericValue(T t) {\n            return static_cast<uintptr_t>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            asGenericValue(BT::toWireType(v)));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n\n#endif // ~C++11 version check\n","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/wire.h> requires building with -std=c++11 or newer!\n#else\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                    return &typeid(T);\n#else\n                    static_assert(!has_unbound_type_names,\n                        \"Unbound type names are illegal with RTTI disabled. \"\n                        \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                        \"from the compiler arguments\");\n                    static_assert(!std::is_polymorphic<C>::value,\n                        \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n                }\n\n                return CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                return &typeid(value);\n#else\n                static_assert(!has_unbound_type_names,\n                    \"Unbound type names are illegal with RTTI disabled. \"\n                    \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                    \"from the compiler arguments\");\n                static_assert(!std::is_polymorphic<C>::value,\n                    \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n            }\n            return LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n\n        template<typename T>\n        constexpr bool typeSupportsMemoryView() {\n            return (std::is_floating_point<T>::value &&\n                        (sizeof(T) == 4 || sizeof(T) == 8)) ||\n                    (std::is_integral<T>::value &&\n                        (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type of typed_memory_view is invalid\");\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n\n#endif // ~C++11 version check\n","#ifndef __LERP_H__\n#define __LERP_H__\n\n#include <stdint.h>\n#include \"instruments.h\"\n\nclass Lerp {\n\tprivate:\n\t\tconst LerpStage* pStart = nullptr;\n\t\tuint8_t loopStart = 0xFF;\n\t\tuint8_t loopEnd = 0xFF;\n\t\tuint8_t stageIndex = 0xFF;\n\t\tint16_t amp = 0;\n\t\tint16_t slope = 0;\n\t\tint8_t limit = -128;\n\t\n\t\tvoid loadStage() volatile {\n\t\t\tLerpStage stage;\n\t\t\tInstruments::getLerpStage(pStart, stageIndex, stage);\n\t\t\tslope = stage.slope;\n\t\t\tlimit = stage.limit;\n\t\t}\n\t\n\tpublic:\n\t\tuint8_t sample() volatile {\n\t\t\tamp += slope;\n\t\t\tint8_t out = amp >> 8;\n\n\t\t\tconst bool nextStage = (out < 0) ||\n\t\t\t\t(slope <= 0)\n\t\t\t\t\t? out <= limit\n\t\t\t\t\t: out >= limit;\n\t\t\n\t\t\tif (nextStage) {\n\t\t\t\tout = limit;\n\t\t\t\tamp = limit << 8;\n\t\t\t\tstageIndex++;\n\t\t\t\tif (stageIndex == loopEnd) {\n\t\t\t\t\tstageIndex = loopStart;\n\t\t\t\t}\n\t\t\t\tloadStage();\n\t\t\t}\n\t\t\n\t\t\treturn out;\n\t\t}\n\t\t\n\t\tvoid start(uint8_t programIndex) volatile {\n\t\t\tLerpProgram program;\n\t\t\tInstruments::getLerpProgram(programIndex, program);\n\t\t\n\t\t\tpStart = program.start;\n\t\t\tloopStart = program.loopStartAndEnd >> 4;\n\t\t\tloopEnd = program.loopStartAndEnd & 0x0F;\n\t\t\tamp = program.initialValue << 8;\n\t\t\tstageIndex = 0;\n\t\t\n\t\t\tloadStage();\n\t\t}\n\n\t\tvoid stop() volatile {\n\t\t\tif (stageIndex < loopEnd) {\n\t\t\t\tstageIndex = loopEnd;\n\t\t\t\tloadStage();\n\t\t\t}\n\t\t}\n\n\t\tfriend class Synth;\n\t\t\n\t\t#ifdef __EMSCRIPTEN__\n\n\t\tuint8_t sampleEm() { return sample(); }\n\t\tvoid startEm(uint8_t program) { start(program); }\n\t\tvoid stopEm() { stop(); }\n\t\tuint8_t getStageIndex() { return stageIndex; }\n\t\t\n\t\t#endif // __EMSCRIPTEN__\n};\n\n#endif //__LERP_H__\n","#ifndef __SYNTH_H__\n#define __SYNTH_H__\n\n#include <avr/interrupt.h>\n#include <stdint.h>\n#include \"instruments.h\"\n\n#define DAC\n\n#ifdef __EMSCRIPTEN__\n\t#define DAC\n\tvoid TIMER2_COMPA_vect();\n#endif\n\nclass Synth {\n    public:\n        constexpr static uint8_t numVoices = 16;\n        constexpr static uint8_t maxVoice = Synth::numVoices - 1;\n\t\tconstexpr static uint8_t samplingInterval = 0x65;\n\t\tconstexpr static double sampleRate = static_cast<double>(F_CPU) / 8.0 / static_cast<double>(Synth::samplingInterval);\n\n        void begin();\n        uint8_t getNextVoice();\n        void noteOn(uint8_t voice, uint8_t note, uint8_t velocity, const Instrument& instrument);\n        void noteOff(uint8_t voice);\n        void pitchBend(uint8_t voice, int16_t value);\n        uint8_t getAmp(uint8_t voice);\n        \n        // Suspends audio processing ISR.  While suspended, it is safe to update of volatile state\n        // shared with the ISR and to communicate with other SPI devices.\n        void suspend() __attribute__((always_inline)) {\n            cli();\n            TIMSK2 = 0;\n            sei();\n        }\n        \n        // Resumes audio processing ISR.\n        void resume() __attribute__((always_inline)) {\n            TIMSK2 = _BV(OCIE2A);\n        }\n        \n#ifdef __EMSCRIPTEN__\n\t\tInstrument instrument0;\n\n\t\tvoid noteOnEm(uint8_t voice, uint8_t note, uint8_t velocity, uint8_t instrumentIndex) {\n\t\t\tInstruments::getInstrument(instrumentIndex, instrument0);\n\t\t\tthis->noteOn(voice, note, velocity, instrument0);\n\t\t}\n\t\t\n\t\tuint16_t sample();\n#endif // __EMSCRIPTEN__\n};\n\n#endif // __SYNTH_H__","#ifndef __MIDISYNTH_H__\r\n#define __MIDISYNTH_H__\r\n\r\n#include <stdint.h>\r#include \"synth.h\"\r\n\r\nclass MidiSynth final : public Synth {\r\n\tprivate:\r\n        constexpr static uint8_t numMidiChannels\t= 16;\t\t\t\t\t// MIDI standard has 16 channels.\r        constexpr static uint8_t maxMidiChannel\t\t= numMidiChannels - 1;\t// Maximum channel is 15 when 0-indexed.\r        constexpr static uint8_t percussionChannel\t= 9;\t\t\t\t\t// Channel 10 is percussion (9 when 0-indexed).\r\r\n        uint8_t voiceToNote[numVoices];\t\t\t\t\t\t\t// Map synth voice to the current MIDI note (or 0xFF if off).\r        uint8_t voiceToChannel[numVoices];\t\t\t\t\t\t// Map synth voice to the current MIDI channel (or 0xFF if off).\r        Instrument channelToInstrument[numMidiChannels];\t\t// Map MIDI channel to the current MIDI program (i.e., instrument).\r\n\r\n    public:\r\t\tMidiSynth() : Synth() {\r\t\t\tfor (int8_t channel = maxMidiChannel; channel >= 0; channel--) {\r\t\t\t\tInstruments::getInstrument(0, channelToInstrument[channel]);\r\t\t\t}\r\r\n\t\t\tfor (int8_t channel = maxMidiChannel; channel >= 0; channel--) {\r\t\t\t\tvoiceToNote[channel] = 0xFF;\r\t\t\t\tvoiceToChannel[channel] = 0xFF;\r\t\t\t}\r\t\t}\r\r\n\t\tvoid midiNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {\r\t\t\tif (channel == percussionChannel) {\t\t\t\t\t\t// If playing the percussion channel\r\t\t\t\tuint8_t index = note - 35;\t\t\t\t\t\t\t//\t Calculate the the index of the percussion instrument relative\r\t\t\t\tif (index >= 46) { index = 45; }\t\t\t\t\t//   to the beginning of the percussion instruments (i.e., less 128).\r\r\n\t\t\t\tnote = Instruments::getPercussionNote(index);\t\t//   Replace the note played with the appropriate frequency for the\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//   percussion instrument.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\tInstruments::getInstrument(0x80 + index,\t\t\t//   Load the percussion instrument into the channelToInstrument map.\r\t\t\t\t\tchannelToInstrument[percussionChannel]);\t\t//   (Note: percussion instruments begin at 128)\r\t\t\t}\r\r\n\t\t\tuint8_t voice = getNextVoice();\t\t\t\t\t\t\t\t\t// Find an available voice to play the note.\r\t\t\tnoteOn(voice, note, velocity, channelToInstrument[channel]);\t// Play the note.\r\r\n\t\t\tvoiceToNote[voice] = note;\t\t\t\t\t\t\t\t// Update our voice -> note/channel maps (used for processing MIDI\r\t\t\tvoiceToChannel[voice] = channel;\t\t\t\t\t\t// pitch bend and note off messages).\r\t\t}\r\r\n\t\tvoid midiNoteOff(uint8_t channel, uint8_t note)  {\r\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\t\t\t\t\t// For each voice\r\t\t\t\tif (voiceToNote[voice] == note && voiceToChannel[voice] == channel) {   //   that is currently playing the note on this channel\r\t\t\t\t\tnoteOff(voice);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//      stop playing the note\r\t\t\t\t\tvoiceToChannel[voice] = 0xFF;\t\t\t\t\t\t\t\t\t\t//      and remove the voice from our voice -> note/channel\r\t\t\t\t\tvoiceToNote[voice] = 0xFF;\t\t\t\t\t\t\t\t\t\t\t//      maps so we ignore it for future node off / pitch bench\r\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//      messages.\r\t\t\t}\r\t\t}\r\r\n\t\tvoid midiProgramChange(uint8_t channel, uint8_t program) {\r\t\t\tInstruments::getInstrument(program, channelToInstrument[channel]);\t\t\t// Load the instrument corresponding to the given MIDI program\r\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// into the MIDI channel -> instrument map.\r\r\n\t\tvoid midiPitchBend(uint8_t channel, int16_t value) {\r\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\t\t\t\t\t// For each voice\r\t\t\t\tif (voiceToChannel[voice] == channel) {\t\t\t\t\t\t\t\t\t//   which is currently playing a note on this channel\r\t\t\t\t\tpitchBend(voice, value);\t\t\t\t\t\t\t\t\t\t\t//     update pitch bench with the given value.\r\t\t\t\t}\r\t\t\t}\r\t\t}\r\t\t\r\t\tvoid midiControlChange(uint8_t channel, uint8_t controller, uint8_t value) {\r\t\t\tswitch (controller) {\r\n\t\t\t\tcase 0x7B: {\r\n\t\t\t\t\tswitch (value) {\r\n\t\t\t\t\t\tcase 0: {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// All Notes Off (for current channel):\r\n\t\t\t\t\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\t\t// For each voice\r\t\t\t\t\t\t\t\tif (voiceToChannel[voice] == channel) {\t\t\t\t\t\t//   currently playing any note on this channel\r\t\t\t\t\t\t\t\t\tnoteOff(voice);\t\t\t\t\t\t\t\t\t\t\t//\t   stop playing the note\r\t\t\t\t\t\t\t\t\tvoiceToChannel[voice] = 0xFF;\t\t\t\t\t\t\t//      and remove the voice from our voice -> note/channel\r\t\t\t\t\t\t\t\t\tvoiceToNote[voice] = 0xFF;\t\t\t\t\t\t\t\t//      maps so we ignore it for future node off / pitch bench\r\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//      messages.\r\t\t\t\t\t\t\t}\r\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r}; //MidiSynth\r\n\r\n#endif //__MIDISYNTH_H__\r\n","#ifndef __INSTRUMENT_H__\n#define __INSTRUMENT_H__\n\nstruct LerpStage {\n\tint16_t slope;\n\tint8_t limit;\n};\n\nstruct LerpProgram {\n\tconst LerpStage* start;\n\tuint8_t initialValue;\n\tuint8_t loopStartAndEnd;\n};\n\n#ifdef __EMSCRIPTEN__\n\n#include <stddef.h>\n\ntemplate<typename T> \nstruct HeapRegion {\n\tsize_t start;\n\tsize_t end;\n\tsize_t itemSize;\n\n\tHeapRegion() {}\n\t\n\tHeapRegion(const T* pStart, const size_t length) {\n\t\tstart = reinterpret_cast<size_t>(pStart);\n\t\tend = start + length;\n\t\titemSize = sizeof(T);\n\t}\n};\n#endif\n\nenum InstrumentFlags : uint8_t {\n    InstrumentFlags_None\t\t\t\t= 0,\n    InstrumentFlags_Noise\t\t\t\t= (1 << 0),\n    InstrumentFlags_HalfAmplitude\t\t= (1 << 1),\n    InstrumentFlags_SelectAmplitude\t\t= (1 << 2),\n    InstrumentFlags_SelectWave\t\t\t= (1 << 3),\n};\n\nstruct Instrument {\n    const int8_t* wave;\n    uint8_t ampMod;\n\tuint8_t freqMod;\n\tuint8_t waveMod;\n    uint8_t xorBits;\n    InstrumentFlags flags;\n};\n\nclass Instruments {\n    public:\n        static void getInstrument(uint8_t index, Instrument& instrument);\n        static uint8_t getPercussionNote(uint8_t index);\n\t\tstatic void getLerpProgram(uint8_t programIndex, LerpProgram& program);\n\t\tstatic void getLerpStage(const LerpStage* pStart, uint8_t stageIndex, LerpStage& stage);\n\n#ifdef __EMSCRIPTEN__\n\t\tstatic const HeapRegion<uint8_t> getPercussionNotes();\n        static const HeapRegion<int8_t> getWavetable();\n\t\tstatic const HeapRegion<LerpProgram> getLerpPrograms();\n\t\tstatic const HeapRegion<LerpStage> getLerpStages();\n\t\tstatic const HeapRegion<Instrument> getInstruments();\n#endif // __EMSCRIPTEN__\n};\n\n#endif // __INSTRUMENT_H__\n","﻿/*\n\tBaseline:\n\t\t\t\tProgram Memory Usage \t:\t32344 bytes   99.0 % Full\r\n\t\t\t\tData Memory Usage \t\t:\t1021 bytes   49.9 % Full\n*/\n\t\t\t\t\n#include <stdint.h>\n#include \"midi.h\"\n#include \"midisynth.h\"\n#include \"instruments.h\"\n#include \"ssd1306.h\"\n\nssd1306 display;\nMidiSynth synth;\n\nvoid noteOn(uint8_t channel, uint8_t note, uint8_t velocity) {\n\tsynth.midiNoteOn(channel, note, velocity);\n}\n\nvoid noteOff(uint8_t channel, uint8_t note) {\n\tsynth.midiNoteOff(channel, note);\n}\n\nvoid sysex(uint8_t cbData, uint8_t data[]) { }\n\nvoid controlChange(uint8_t channel, uint8_t control, uint8_t value) {\n\tsynth.midiControlChange(channel, control, value);\n}\n\nvoid programChange(uint8_t channel, uint8_t value) {\n    synth.midiProgramChange(channel, value);\n}\n\nvoid pitchBend(uint8_t channel, int16_t value) {\n\tsynth.midiPitchBend(channel, value);\n}\n\n#include <avr/io.h>\n\nvoid setup() {   \n    midi_setup();\n\n    display.begin();\n    display.reset();\n    display.setRegion(0, 127, 0, 7, 0);\n    \n    synth.begin();\n    \n    sei();\n}\n\nvoid loop() {\n    static uint8_t displayChannel = 0;\n\n    displayChannel++;\n    displayChannel &= 0x0F;\n\n    uint8_t y = synth.getAmp(displayChannel);\n\tif (y < 96) {\n\t\ty += y >> 1;\n\t} else {\n\t\ty = 128;\n\t}\n\t\n    const uint8_t x = displayChannel << 3;\n    const int8_t page = 7 - (y >> 3);\n    midi_process();\n    \n    synth.suspend();                                // Suspend audio processing ISR so display can use SPI.\n    display.select(x, x + 6, 0, 7);             \n    synth.resume();\n    \n    // Set [0 .. page - 1]\n    for (int8_t i = page; i > 0; i--) {\n        synth.suspend();                            // Suspend audio processing ISR so display can use SPI.\n        display.send7(0x00);\n        synth.resume();\n        midi_process();\n    }\n\n    {\n        uint8_t remainder = 7 - (y & 0x07);\n        synth.suspend();                            // Suspend audio processing ISR so display can use SPI.\n        display.send7(~((1 << remainder) - 1));\n        synth.resume();\n        midi_process();\n    }\n\n    // Clear [page + 1 .. 7]\n    for (int8_t i = 6 - page; i >= 0; i--) {\n        synth.suspend();                            // Suspend audio processing ISR so display can use SPI.\n        display.send7(0xFF);\n        synth.resume();\n        midi_process();\n    }\n}\n\n#ifndef __EMSCRIPTEN__\nint main() {\n    setup();\n    \n    while(true) {\n        loop();\n    }\n    \n    return 0;\n}\n#endif // !__EMSCRIPTEN__","#ifndef __SSD1306_H__\n#define __SSD1306_H__\n\n#include <stdint.h>\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <util/delay.h>\n\n// https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf\nenum Command: uint8_t {\n\tCommand_SetMemAddressMode   = 0x20,         // 00 = Horiz, 01 = Vert, 10 = Page, 11 = Invalid\n\tCommand_SetDisplayStartLine = 0x40,         // +0..63 to select the start line.\n\tCommand_SetMultiplexRatio   = 0xA8,         // A[7:0] = Multiplex ratio in the range 16..63\n\tCommand_SetDisplayClock     = 0xD5,         // A[3:0] = DCLK divide ratio, A[7:4] = Oscillator frequency\n\tCommand_SetSegmentRemap     = 0xA0,         // +1 maps column 127 to SEG 0\n\tCommand_SetDisplayOff       = 0xAE,\n\tCommand_SetDisplayOn        = 0xAF,\n\tCommand_SetComOutScanDir    = 0xC0,         // Scan from COM0 -> COM[N-1], N = Multiplex Ratio (C8 is reverse)\n\tCommand_SetDisplayOffset    = 0xD3,\n\tCommand_SetChargePump       = 0x8D,         // 0x10 - Disable, 0x14 - Enable [See App Note pg 3/6.]\n\tCommand_SetCOMPins          = 0xDA,         // A[4] = Alternate config, A[5] = Enable Left/Right remap\n\tCommand_SetContrast         = 0x81,         // A[7:0] = Value (increases to 0xFF, reset = 0x7F)\n\tCommand_SetPreChargePeriod  = 0xD9,         // A[3:0] = Phase 1 (1..15 DCLK), A[7:4] = Phase 2 (1..15 DCLK)\n\tCommand_DisplayResume       = 0xA4,         // Resume displaying RAM contents\n\tCommand_SetNormalDisplay    = 0xA6,         // +1 to invert display\n\tCommand_DeactivateScroll    = 0x2E,         // Stop scrolling\n\tCommand_SetVComHDeselectLvl = 0xDB,         // [A6:4] = 00 ~0.65 Vcc, 10 = ~0.77 Vcc, 11 = ~0.83 Vcc\n\tCommand_SetColumnAddr       = 0x21,\n\tCommand_SetPageAddr         = 0x22,\n};\n\n// A specialized driver for SSD1306-based OLED display used to concurrently update the real-time bar\n// graph in tiny time slices, interspersed with dispatching MIDI in the main loop.\n\nclass ssd1306 final {\npublic:\n\tssd1306() {}\n    \n\tvoid begin() {\n\t    PORTD |= _resPin | _dcPin | _csPin;             // Set display RES/DC/CS pins HIGH.\n\t    DDRD  |= _resPin | _dcPin | _csPin;             // Set display RES/DC/CS pins as output.\n\n\t    PORTB |= _BV(DDB2);                             // Must also set default SPI CS pin as output, even\n\t    DDRB |= _BV(DDB2);                              // if we're not using it for the display.\n\n\t    SPSR |= _BV(SPI2X);                             // SCK = F_CPU/2\n\t    SPCR = _BV(SPE) | _BV(MSTR);                    // Enable SPI, Master\n\t    \n\t    DDRB |= _BV(DDB5) | _BV(DDB3);                  // Set MOSI and SCK as outputs after enabling SPI.\n    }\n\t\n    void reset() {\n\t    PORTD |= _resPin;\n\t    _delay_ms(100);\n\t    PORTD &= ~_resPin;\n\t    _delay_ms(100);\n\t    PORTD |= _resPin;\n\n\t    // Use the same configuration as olikraus's excellent U8G2 library:\n\t    // https://github.com/olikraus/u8g2/blob/master/csrc/u8x8_d_ssd1306_128x64_noname.c\n\n\t    beginCommand();\n\t    send(Command_SetDisplayOff);\n\t    send(Command_SetDisplayClock);\n\t    send(0x80);\n\t    send(Command_SetMultiplexRatio);\n\t    send(0x3F);\n\t    send(Command_SetDisplayOffset);\n\t    send(0x00);\n\t    send(Command_SetDisplayStartLine);\n\t    send(Command_SetChargePump);\n\t    send(0x14);\n\t    send(Command_SetMemAddressMode);\n\t    send(0x00);\n#ifndef ROTATE_180\n\t    send(Command_SetSegmentRemap);\n\t    send(Command_SetComOutScanDir);\n#else\n\t    send(Command_SetSegmentRemap | 0x01);\n\t    send(Command_SetComOutScanDir | 0x08);\n#endif\n\t    send(Command_SetCOMPins);\n\t    send(0x12);\n\t    send(Command_SetContrast);\n\t    send(0xCF);\n\t    send(Command_SetPreChargePeriod);\n\t    send(0xF1);\n\t    send(Command_SetVComHDeselectLvl);\n\t    send(0x40);\n\t    send(Command_DeactivateScroll);\n\t    send(Command_DisplayResume);\n\t    send(Command_SetNormalDisplay);\n\t    send(Command_SetDisplayOn);\n\t    endCommand();\n    }\n\n    void select(uint8_t minX, uint8_t maxX, uint8_t minPage, uint8_t maxPage) {\n\t    beginCommand();\n\t    send(Command_SetColumnAddr);\n\t    send(minX);\n\t    send(maxX);\n\n\t    send(Command_SetPageAddr);\n\t    send(minPage);\n\t    send(maxPage);\n\t    endCommand();\n    }\n    \n\tvoid setRegion(uint8_t minX, uint8_t maxX, uint8_t minPage, uint8_t maxPage, uint8_t value) __attribute__((always_inline)) {\n\t    select(minX, maxX, minPage, maxPage);\n\t    \n\t    const uint8_t numX = maxX - minX;\n\t    const uint8_t numPage = maxPage - minPage;\n\t    \n\t    beginData();\n\t    for (int8_t y = numPage; y >= 0; y--) {\n\t\t    for (int8_t x = numX; x >= 0; x--) {\n\t\t\t    send(value);\n\t\t    }\n\t    }\n\t    endData();\n    }\n\t\n    void send7(uint8_t value) __attribute__((always_inline)) {\n\t    beginData();\n\t    send(value);\n\t    send(value);\n\t    send(value);\n\t    send(value);\n\t    send(value);\n\t    send(value);\n\t    send(value);\n\t    endData();\n    }\n    \nprivate:\n    static constexpr uint8_t _resPin = _BV(DDD2);\n    static constexpr uint8_t  _dcPin = _BV(DDD3);\n    static constexpr uint8_t  _csPin = _BV(DDD4);\n    \n    static constexpr uint8_t _cmdPins   = _csPin | _dcPin;\n    static constexpr uint8_t _dataPins  = _csPin;\n\n    void send(const uint8_t data) __attribute__((always_inline)) {\n        SPDR = data;\n        while (!(SPSR & _BV(SPIF)));\n    }\n\n    void beginCommand() __attribute__((always_inline)) {\n        PORTD &= ~_cmdPins;         // Select SSD1306 for command.\n    }\n    \n    void endCommand() __attribute__((always_inline)) {\n        PORTD |= _cmdPins;          // Deselect SSD1306.\n    }\n\n    void beginData() __attribute__((always_inline)) {\n        PORTD &= ~_dataPins;        // Select SSD1306 for data.\n    }\n    \n    void endData() __attribute__((always_inline)) {\n        PORTD |= _dataPins;         // Deselect SSD1306.\n    }\n};\n\n#endif //__SSD1306_H__","#ifndef __MIDISYNTH_H__\r\n#define __MIDISYNTH_H__\r\n\r\n#include <stdint.h>\r#include \"synth.h\"\r\n\r\nclass MidiSynth final : public Synth {\r\n\tprivate:\r\n        constexpr static uint8_t numMidiChannels\t= 16;\t\t\t\t\t// MIDI standard has 16 channels.\r        constexpr static uint8_t maxMidiChannel\t\t= numMidiChannels - 1;\t// Maximum channel is 15 when 0-indexed.\r        constexpr static uint8_t percussionChannel\t= 9;\t\t\t\t\t// Channel 10 is percussion (9 when 0-indexed).\r\r\n        uint8_t voiceToNote[numVoices];\t\t\t\t\t\t\t// Map synth voice to the current MIDI note (or 0xFF if off).\r        uint8_t voiceToChannel[numVoices];\t\t\t\t\t\t// Map synth voice to the current MIDI channel (or 0xFF if off).\r        Instrument channelToInstrument[numMidiChannels];\t\t// Map MIDI channel to the current MIDI program (i.e., instrument).\r\n\r\n    public:\r\t\tMidiSynth() : Synth() {\r\t\t\tfor (int8_t channel = maxMidiChannel; channel >= 0; channel--) {\r\t\t\t\tInstruments::getInstrument(0, channelToInstrument[channel]);\r\t\t\t}\r\r\n\t\t\tfor (int8_t channel = maxMidiChannel; channel >= 0; channel--) {\r\t\t\t\tvoiceToNote[channel] = 0xFF;\r\t\t\t\tvoiceToChannel[channel] = 0xFF;\r\t\t\t}\r\t\t}\r\r\n\t\tvoid midiNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {\r\t\t\tif (channel == percussionChannel) {\t\t\t\t\t\t// If playing the percussion channel\r\t\t\t\tuint8_t index = note - 35;\t\t\t\t\t\t\t//\t Calculate the the index of the percussion instrument relative\r\t\t\t\tif (index >= 46) { index = 45; }\t\t\t\t\t//   to the beginning of the percussion instruments (i.e., less 128).\r\r\n\t\t\t\tnote = Instruments::getPercussionNote(index);\t\t//   Replace the note played with the appropriate frequency for the\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//   percussion instrument.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\tInstruments::getInstrument(0x80 + index,\t\t\t//   Load the percussion instrument into the channelToInstrument map.\r\t\t\t\t\tchannelToInstrument[percussionChannel]);\t\t//   (Note: percussion instruments begin at 128)\r\t\t\t}\r\r\n\t\t\tuint8_t voice = getNextVoice();\t\t\t\t\t\t\t\t\t// Find an available voice to play the note.\r\t\t\tnoteOn(voice, note, velocity, channelToInstrument[channel]);\t// Play the note.\r\r\n\t\t\tvoiceToNote[voice] = note;\t\t\t\t\t\t\t\t// Update our voice -> note/channel maps (used for processing MIDI\r\t\t\tvoiceToChannel[voice] = channel;\t\t\t\t\t\t// pitch bend and note off messages).\r\t\t}\r\r\n\t\tvoid midiNoteOff(uint8_t channel, uint8_t note)  {\r\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\t\t\t\t\t// For each voice\r\t\t\t\tif (voiceToNote[voice] == note && voiceToChannel[voice] == channel) {   //   that is currently playing the note on this channel\r\t\t\t\t\tnoteOff(voice);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//      stop playing the note\r\t\t\t\t\tvoiceToChannel[voice] = 0xFF;\t\t\t\t\t\t\t\t\t\t//      and remove the voice from our voice -> note/channel\r\t\t\t\t\tvoiceToNote[voice] = 0xFF;\t\t\t\t\t\t\t\t\t\t\t//      maps so we ignore it for future node off / pitch bench\r\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//      messages.\r\t\t\t}\r\t\t}\r\r\n\t\tvoid midiProgramChange(uint8_t channel, uint8_t program) {\r\t\t\tInstruments::getInstrument(program, channelToInstrument[channel]);\t\t\t// Load the instrument corresponding to the given MIDI program\r\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// into the MIDI channel -> instrument map.\r\r\n\t\tvoid midiPitchBend(uint8_t channel, int16_t value) {\r\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\t\t\t\t\t// For each voice\r\t\t\t\tif (voiceToChannel[voice] == channel) {\t\t\t\t\t\t\t\t\t//   which is currently playing a note on this channel\r\t\t\t\t\tpitchBend(voice, value);\t\t\t\t\t\t\t\t\t\t\t//     update pitch bench with the given value.\r\t\t\t\t}\r\t\t\t}\r\t\t}\r\t\t\r\t\tvoid midiControlChange(uint8_t channel, uint8_t controller, uint8_t value) {\r\t\t\tswitch (controller) {\r\n\t\t\t\tcase 0x7B: {\r\n\t\t\t\t\tswitch (value) {\r\n\t\t\t\t\t\tcase 0: {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// All Notes Off (for current channel):\r\n\t\t\t\t\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\t\t// For each voice\r\t\t\t\t\t\t\t\tif (voiceToChannel[voice] == channel) {\t\t\t\t\t\t//   currently playing any note on this channel\r\t\t\t\t\t\t\t\t\tnoteOff(voice);\t\t\t\t\t\t\t\t\t\t\t//\t   stop playing the note\r\t\t\t\t\t\t\t\t\tvoiceToChannel[voice] = 0xFF;\t\t\t\t\t\t\t//      and remove the voice from our voice -> note/channel\r\t\t\t\t\t\t\t\t\tvoiceToNote[voice] = 0xFF;\t\t\t\t\t\t\t\t//      maps so we ignore it for future node off / pitch bench\r\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//      messages.\r\t\t\t\t\t\t\t}\r\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r}; //MidiSynth\r\n\r\n#endif //__MIDISYNTH_H__\r\n","#include <avr/pgmspace.h>\r\n#include <avr/io.h>\r\n#include <avr/common.h>\r\n#include <avr/interrupt.h>\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n#include \"synth.h\"\r\n#include \"lerp.h\"\r\n#include \"drivers/dac/ltc16xx.h\"\r\n\r\nLtc16xx<PinId::D10> _dac;\r\n\r\n#ifndef __EMSCRIPTEN__\r\nconstexpr static uint16_t pitch(double note) {\r\n\treturn round(pow(2, (note - 69.0) / 12.0) * 440.0 / Synth::sampleRate * static_cast<double>(0xFFFF));\r\n}\r\n#endif\r\n\r\n// Map MIDI notes [0..127] to the corresponding Q8.8 sampling interval\r\nconstexpr static uint16_t _noteToPitch[] PROGMEM = {\r\n#ifndef __EMSCRIPTEN__\r\n\tpitch(0x00), pitch(0x01), pitch(0x02), pitch(0x03), pitch(0x04), pitch(0x05), pitch(0x06), pitch(0x07), pitch(0x08), pitch(0x09), pitch(0x0A), pitch(0x0B), pitch(0x0C), pitch(0x0D), pitch(0x0E), pitch(0x0F),\r\n\tpitch(0x10), pitch(0x11), pitch(0x12), pitch(0x13), pitch(0x14), pitch(0x15), pitch(0x16), pitch(0x17), pitch(0x18), pitch(0x19), pitch(0x1A), pitch(0x1B), pitch(0x1C), pitch(0x1D), pitch(0x1E), pitch(0x1F),\r\n\tpitch(0x20), pitch(0x21), pitch(0x22), pitch(0x23), pitch(0x24), pitch(0x25), pitch(0x26), pitch(0x27), pitch(0x28), pitch(0x29), pitch(0x2A), pitch(0x2B), pitch(0x2C), pitch(0x2D), pitch(0x2E), pitch(0x2F),\r\n\tpitch(0x30), pitch(0x31), pitch(0x32), pitch(0x33), pitch(0x34), pitch(0x35), pitch(0x36), pitch(0x37), pitch(0x38), pitch(0x39), pitch(0x3A), pitch(0x3B), pitch(0x3C), pitch(0x3D), pitch(0x3E), pitch(0x3F),\r\n\tpitch(0x40), pitch(0x41), pitch(0x42), pitch(0x43), pitch(0x44), pitch(0x45), pitch(0x46), pitch(0x47), pitch(0x48), pitch(0x49), pitch(0x4A), pitch(0x4B), pitch(0x4C), pitch(0x4D), pitch(0x4E), pitch(0x4F),\r\n\tpitch(0x50), pitch(0x51), pitch(0x52), pitch(0x53), pitch(0x54), pitch(0x55), pitch(0x56), pitch(0x57), pitch(0x58), pitch(0x59), pitch(0x5A), pitch(0x5B), pitch(0x5C), pitch(0x5D), pitch(0x5E), pitch(0x5F),\r\n\tpitch(0x60), pitch(0x61), pitch(0x62), pitch(0x63), pitch(0x64), pitch(0x65), pitch(0x66), pitch(0x67), pitch(0x68), pitch(0x69), pitch(0x6A), pitch(0x6B), pitch(0x6C), pitch(0x6D), pitch(0x6E), pitch(0x6F),\r\n\tpitch(0x70), pitch(0x71), pitch(0x72), pitch(0x73), pitch(0x74), pitch(0x75), pitch(0x76), pitch(0x77), pitch(0x78), pitch(0x79), pitch(0x7A), pitch(0x7B), pitch(0x7C), pitch(0x7D), pitch(0x7E), pitch(0x7F),\r\n#else\r\n\t// Map MIDI notes [0..127] to the corresponding Q8.8 sampling interval at ~20 kHz\r\n\t0x001B, 0x001D, 0x001E, 0x0020, 0x0022, 0x0024, 0x0026, 0x0029, 0x002B, 0x002E, 0x0030, 0x0033, 0x0036, 0x0039, 0x003D, 0x0040,\r\n\t0x0044, 0x0048, 0x004D, 0x0051, 0x0056, 0x005B, 0x0060, 0x0066, 0x006C, 0x0073, 0x0079, 0x0081, 0x0088, 0x0090, 0x0099, 0x00A2,\r\n\t0x00AC, 0x00B6, 0x00C1, 0x00CC, 0x00D8, 0x00E5, 0x00F3, 0x0101, 0x0111, 0x0121, 0x0132, 0x0144, 0x0158, 0x016C, 0x0182, 0x0199,\r\n\t0x01B1, 0x01CB, 0x01E6, 0x0203, 0x0221, 0x0242, 0x0264, 0x0289, 0x02AF, 0x02D8, 0x0303, 0x0331, 0x0362, 0x0395, 0x03CC, 0x0406,\r\n\t0x0443, 0x0484, 0x04C9, 0x0511, 0x055E, 0x05B0, 0x0607, 0x0663, 0x06C4, 0x072B, 0x0798, 0x080B, 0x0886, 0x0908, 0x0991, 0x0A23,\r\n\t0x0ABD, 0x0B60, 0x0C0E, 0x0CC5, 0x0D87, 0x0E55, 0x0F30, 0x1017, 0x110C, 0x120F, 0x1322, 0x1445, 0x157A, 0x16C1, 0x181B, 0x198A,\r\n\t0x1B0F, 0x1CAB, 0x1E5F, 0x202D, 0x2217, 0x241E, 0x2644, 0x288B, 0x2AF4, 0x2D82, 0x3036, 0x3314, 0x361E, 0x3955, 0x3CBE, 0x405B,\r\n\t0x442F, 0x483C, 0x4C88, 0x5115, 0x55E7, 0x5B03, 0x606C, 0x6628, 0x6C3B, 0x72AB, 0x797C, 0x80B6, 0x885D, 0x9079, 0x9910, 0xA22A,\r\n#endif\r\n};\r\n\r\nvolatile const int8_t*  v_wave[Synth::numVoices]    = { 0 };        // Starting address of 256b wave table.\r\nvolatile uint16_t       v_phase[Synth::numVoices]   = { 0 };        // Phase accumulator holding the Q8.8 offset of the next sample.\r\nvolatile uint16_t       v_pitch[Synth::numVoices]   = { 0 };        // Q8.8 sampling period, used to advance the '_phase' accumulator.\r\nvolatile int8_t         v_xor[Synth::numVoices]     = { 0 };        // XOR bits applied to each sample (for effect).\r\nvolatile uint8_t        v_amp[Synth::numVoices]     = { 0 };        // 6-bit amplitude scale applied to each sample.\r\nvolatile bool           v_isNoise[Synth::numVoices] = { 0 };        // If true, '_xor' is periodically overwritten with random values.\r\n\r\nvolatile Lerp           v_ampMod[Synth::numVoices]  = {};           // Amplitude modulation\r\nvolatile Lerp           v_freqMod[Synth::numVoices] = {};\t\t\t// Frequency modulation\r\nvolatile Lerp           v_waveMod[Synth::numVoices] = {};\t\t\t// Wave offset modulation\r\n\t\r\nvolatile uint8_t        v_vol[Synth::numVoices]     = { 0 };        // 7-bit volume scalar applied to ADSR output.\r\n\r\nvolatile uint16_t\t\tv_basePitch[Synth::numVoices]\t= { 0 };\t// Original Q8.8 sampling period, prior to modulation, pitch bend, etc.\r\nvolatile uint16_t\t\tv_bentPitch[Synth::numVoices]\t= { 0 };\t// Q8.8 sampling post pitch bend, but prior to freqMod.\r\nvolatile const int8_t*  v_baseWave[Synth::numVoices]\t= { 0 };    // Original starting address in wavetable.\r\nvolatile uint8_t\t\t_note[Synth::numVoices]\t\t\t= { 0 };    // Index of '_basePitch' in the '_pitches' table, used for pitch bend calculation.\r\n\r\n// Audio output as biased/unsigned (0 signed -> 0x8000).\r\nuint16_t wavOut = 0x8000;\r\n\r\nSIGNAL(TIMER2_COMPA_vect) {\r\n#ifndef DAC\r\n\tOCR0A = wavOut >> 8;\t\t// Update PWM outputs prior to re-enabling interrupts to write OCR0A/B\r\tOCR0B = wavOut & 0xFF;\t\t// as atomically as possible.\r\n#endif\r\n\t\r\n    TIMSK2 = 0;         // Disable timer2 interrupts to prevent reentrancy.\r\n    sei();              // Re-enable interrupts to ensure we do not miss MIDI events.\r\n    \r\n    {\r\n        static uint16_t noise = 0xACE1;                     // 16-bit maximal-period Galois LFSR\r\n        noise = (noise >> 1) ^ (-(noise & 1) & 0xB400);     // https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs\r\n        \r\n        static uint8_t divider = 0;                         // Time division is used to spread lower-frequency / periodic work\r\n        divider++;                                          // across interrupts.\r\n        \r\n        const uint8_t voice = divider & 0x0F;\t\t\t\t// Bottom 4 bits of 'divider' selects which voice to perform work on.\r\n        \r\n        if (v_isNoise[voice]) {                             // To avoid needing a large wavetable for noise, we use xor to combine\r\n            v_xor[voice] = static_cast<uint8_t>(noise);     // the a 256B wavetable with samples from the LFSR.\r\n        }\r\n\r\n        const uint8_t fn = divider & 0xF0;                  // Top 4 bits of 'divider' selects which additional work to perform.\r\n        switch (fn) {\r\n\t\t\tcase 0x00: {\t\t\t\t\t\t\t\t\t// Advance frequency modulation and update 'v_pitch' for the current voice.\r\n\t\t\t\tint8_t freqMod = (v_freqMod[voice].sample() - 0x40);\r\n\t\t\t\tv_pitch[voice] = v_bentPitch[voice] + freqMod;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcase 0x50: {\t\t\t\t\t\t\t\t\t// Advance wave modulation and update 'v_wave' for the current voice.\r\n\t\t\t\tint8_t waveMod = (v_waveMod[voice].sample());\r\n\t\t\t\tv_wave[voice] = v_baseWave[voice] + waveMod;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase 0xA0: {                                    // Advance the amplitude modulation and update 'v_amp' for the current voice.\r\n                uint16_t amp = v_ampMod[voice].sample();\r\n                v_amp[voice] = (amp * v_vol[voice]) >> 8;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Each interrupt, we transmit the previous output to the DAC concurrently with calculating\r\n    // the next wavOut.  This avoids unproductive busy-waiting for SPI to finish.\r\n        \r\n#ifdef DAC    \r\n    _dac.sendHiByte(wavOut >> 8);\t\t\t\t\t\t\t\t\t\t// Begin transmitting upper 8-bits to DAC.\r\n#endif\r\n\r\n    // Macro that advances '_phase[voice]' by the sampling interval '_pitch[voice]' and stores the next 8-bit\r\n    // sample offset as 'offset##voice'.\r\n    #define PHASE(voice) uint8_t offset##voice = ((v_phase[voice] += v_pitch[voice]) >> 8)\r\n\r\n    // Macro that samples the wavetable at the offset '_wave[voice] + offset##voice', and stores as 'sample##voice'.\r\n    #define SAMPLE(voice) int8_t sample##voice = (pgm_read_byte(v_wave[voice] + offset##voice))\r\n\r\n    // Macro that applies '_xor[voice]' to 'sample##voice' and multiplies by '_amp[voice]'.\r\n    #define MIX(voice) ((sample##voice ^ v_xor[voice]) * v_amp[voice])\r\n    \r\n    // We The below sampling/mixing code is carefully arranged to allow the compiler to make use of fixed\r\n    // offsets for loads and stores, and to leave temporary calculations in register.\r\n    \r\n    PHASE(0); PHASE(1); PHASE(2); PHASE(3);                             // Advance the Q8.8 phase and calculate the 8-bit offsets into the wavetable.\r\n    PHASE(4); PHASE(5); PHASE(6); PHASE(7);                             // (Load stores should use constant offsets and results should stay in register.)\r\n    \r\n    SAMPLE(0); SAMPLE(1); SAMPLE(2); SAMPLE(3);                         // Sample the wavetables at the offsets calculated above.\r\n    SAMPLE(4); SAMPLE(5); SAMPLE(6); SAMPLE(7);                         // (Samples should stay in register.)\r\n    \r\n    int16_t mix = (MIX(0) + MIX(1) + MIX(2) + MIX(3)) >> 1;             // Apply xor, modulate by amp, and mix.\r\n    mix += (MIX(4) + MIX(5) + MIX(6) + MIX(7)) >> 1;\r\n\r\n#ifdef DAC\r\n    _dac.sendLoByte(wavOut);\t\t\t\t\t\t\t\t\t\t\t// Begin transmitting the lower 8-bits.\r\n#endif\r\n\r\n    PHASE(8); PHASE(9); PHASE(10); PHASE(11);                           // Advance the Q8.8 phase and calculate the 8-bit offsets into the wavetable.\r\n    PHASE(12); PHASE(13); PHASE(14); PHASE(15);                         // (Load stores should use constant offsets and results should stay in register.)\r\n    \r\n    SAMPLE(8); SAMPLE(9); SAMPLE(10); SAMPLE(11);                       // Sample the wavetables at the offsets calculated above.\r\n    SAMPLE(12); SAMPLE(13); SAMPLE(14); SAMPLE(15);                     // (Samples should stay in register.)\r\n    \r\n    mix += (MIX(8) + MIX(9) + MIX(10) + MIX(11)) >> 1;                  // Apply xor, modulate by amp, and mix.\r\n    mix += (MIX(12) + MIX(13) + MIX(14) + MIX(15)) >> 1;\r\n    \r\n    wavOut = mix + 0x8000;                                              // Store resulting wave output for transmission on next interrupt.\r\n\r\n#ifdef DAC\r\n\t_dac.end();\r\n#endif\r\n\t\r\n    TIMSK2 = _BV(OCIE2A);                                               // Restore timer2 interrupts.\r\n}\r\n\r\n#ifdef __EMSCRIPTEN__\r\nuint16_t Synth::sample() {\r\n\tTIMER2_COMPA_vect();\r\n\treturn wavOut;\r\n}\r\n#endif // __EMSCRIPTEN__\r\n\r\n// Returns the next idle voice, if any.  If no voice is idle, uses ADSR stage and amplitude to\r\n// choose the best candidate for note-stealing.\r\nuint8_t Synth::getNextVoice() {\r\n    uint8_t current = maxVoice;   \r\n\tuint8_t currentStage;\r\n\tint8_t currentAmp;\r\n\t\r\n\t{\r\n\t\tconst volatile Lerp& currentMod\t= v_ampMod[current];\r\n\t\tcurrentStage = currentMod.stageIndex;\r\n\t\tcurrentAmp = currentMod.amp;\r\n\t}\r\n\r\n    for (int8_t candidate = maxVoice - 1; candidate >= 0; candidate--) {\r\n        const volatile Lerp& candidateMod = v_ampMod[candidate];\r\n        const uint8_t candidateStage = candidateMod.stageIndex;\r\n        \r\n        if (candidateStage >= currentStage) {                                  // If the currently chosen voice is in a later ADSR stage, keep it.\r\n            if (candidateStage == currentStage) {                              // Otherwise, if both voices are in the same ADSR stage\r\n                const int8_t candidateAmp = candidateMod.amp;                  //   compare amplitudes to determine which voice to prefer.\r\n            \r\n                bool selectCandidate = candidateMod.slope > 0                  // If amplitude is increasing...\r\n                    ? candidateAmp >= currentAmp                               //   prefer the lower amplitude voice\r\n                    : candidateAmp <= currentAmp;                              //   otherwise the higher amplitude voice\r\n\r\n                if (selectCandidate) {\r\n                    current = candidate;\r\n\t\t\t\t\tcurrentStage = candidateStage;\r\n\t\t\t\t\tcurrentAmp = candidateAmp;\r\n                }\r\n            } else {\r\n                current = candidate;\t\t\t\t\t\t\t\t\t\t\t// Else, if the candidate is in a later ADSR stage, prefer it.\r\n\t\t\t\tcurrentStage = candidateStage;\r\n\t\t\t\tcurrentAmp = candidateMod.amp;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return current;\r\n}\r\n\r\nconstexpr uint8_t offsetTable[] = { 0, 0, 1, 1, 2, 3, 3, 3 };\r\n\r\nvoid Synth::noteOn(uint8_t voice, uint8_t note, uint8_t velocity, const Instrument& instrument) {\r\n\tconst uint8_t flags = instrument.flags;\r\n    if (flags & InstrumentFlags_HalfAmplitude) {\r\n        velocity >>= 1;\r\n    }\r\n    \r\n    bool isNoise = flags & InstrumentFlags_Noise;\r\n\t\r\n\tuint8_t noteOffset = offsetTable[note >> 4];\r\n\tuint8_t ampOffset = flags & InstrumentFlags_SelectAmplitude\r\n\t\t? noteOffset\r\n\t\t: 0;\r\n\t\t\r\n\tuint8_t waveOffset = flags & InstrumentFlags_SelectWave\r\n\t\t? noteOffset << 6\r\n\t\t: 0;\r\n\t\t\r\n    _note[voice] = note;\r\n\r\n    uint16_t pitch = pgm_read_word(&_noteToPitch[note]);\r\n\r\n#if DEBUG\r\n\tpitch <<= 1;\t\t\t\t\t\t// Reduce sampling frequency by 1/2 in DEBUG (non-optimized) builds to\r\n#endif                                  // avoid starving MIDI dispatch.\r\n\r\n    // Suspend audio processing before updating state shared with the ISR.\r\n    suspend();\r\n\r\n    v_wave[voice] = v_baseWave[voice] = instrument.wave + waveOffset;\r\n    v_phase[voice] = 0;\r\n    v_pitch[voice] = v_bentPitch[voice] = v_basePitch[voice] = pitch;\r\n    v_xor[voice] = instrument.xorBits;\r\n    v_amp[voice] = 0;\r\n    v_isNoise[voice] = isNoise;\r\n    v_vol[voice] = velocity;\r\n    v_ampMod[voice].start(instrument.ampMod + ampOffset);\r\n\tv_freqMod[voice].start(instrument.freqMod);\r\n\tv_waveMod[voice].start(instrument.waveMod);\r\n    \r\n    resume();\r\n}\r\n\r\nvoid Synth::noteOff(uint8_t voice) {\r\n    // Suspend audio processing before updating state shared with the ISR.\r\n    suspend();\r\n    v_ampMod[voice].stop();\r\n    resume();\r\n}\r\n\r\nvoid Synth::pitchBend(uint8_t voice, int16_t value) {\r\n    uint16_t pitch = v_basePitch[voice];\r\n    uint16_t delta = value >= 0\r\n\t\t? pgm_read_word(&_noteToPitch[_note[voice] + 2]) - pitch\r\n\t\t: pitch - pgm_read_word(&_noteToPitch[_note[voice] - 2]);\r\n\r\n\tint32_t product;\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t// https://mekonik.wordpress.com/2009/03/18/arduino-avr-gcc-multiplication/\r\n\tasm volatile (\r\n\t\t\"clr r26 \\n\\t\"\r\n\t\t\"mul %A1, %A2 \\n\\t\"\r\n\t\t\"movw %A0, r0 \\n\\t\"\r\n\t\t\"mulsu %B1, %B2 \\n\\t\"\r\n\t\t\"movw %C0, r0 \\n\\t\"\r\n\t\t\"mul %B2, %A1 \\n\\t\"\r\n\t\t\"add %B0, r0 \\n\\t\"\r\n\t\t\"adc %C0, r1 \\n\\t\"\r\n\t\t\"adc %D0, r26 \\n\\t\"\r\n\t\t\"mulsu %B1, %A2 \\n\\t\"\r\n\t\t\"sbc %D0, r26 \\n\\t\"\r\n\t\t\"add %B0, r0 \\n\\t\"\r\n\t\t\"adc %C0, r1 \\n\\t\"\r\n\t\t\"adc %D0, r26 \\n\\t\"\r\n\t\t\"clr r1 \\n\\t\"\r\n\t\t: \"=&r\" (product)\r\n\t\t: \"a\" (value), \"a\" (delta)\r\n\t\t: \"r26\");\r\n#else\r\n\tproduct = value * delta;\r\n#endif\r\n\r\n    pitch += static_cast<int16_t>(product / 0x2000);\r\n\r\n    // Suspend audio processing before updating state shared with the ISR.\r\n    suspend();\r\n    v_bentPitch[voice] = pitch;\r\n    resume();\r\n}\r\n\r\nuint8_t Synth::getAmp(uint8_t voice) {\r\n    return v_amp[voice];\r\n}\r\n\r\nvoid Synth::begin() {\r\n#ifdef DAC\r\n\t_dac.setup();\r\n#else\r\n\t//// Setup Timer1 for PWM\r\n    //TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(WGM11);    // Toggle OC1A/OC1B on Compare Match, Fast PWM (non-inverting)\r\n    //TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10);       // Fast PWM, Top ICR1H/L, Prescale None\r\n    //ICR1H = 0;\r\n    //ICR1L = 0xFF;                                       // Top = 255 (8-bit PWM per output), 62.5khz carrier frequency\r\n    //DDRB |= _BV(DDB1) | _BV(DDB2);                      // Output PWM to DDB1 / DDB2                                                                                        \r\n    //TIMSK1 = 0;\r\n\t\r\n\t// Setup Timer0 for PWM\r\n    TCCR0A = _BV(COM0A1) | _BV(COM0B1) | _BV(WGM01) | _BV(WGM00);   // Fast PWM (non-inverting), Top 0xFF\r\n    TCCR0B = _BV(CS10);\t\t\t\t\t\t\t\t\t\t\t\t// Prescale None\r\n    DDRD |= _BV(DDD5) | _BV(DDD6);\t\t\t\t\t\t\t\t\t// Output PWM to DDD5 / DDD6\r\n#endif\r\n\r\n    TCCR2A = _BV(WGM21);                // CTC Mode (Clears timer and raises interrupt when OCR2B reaches OCR2A)\r\n    TCCR2B = _BV(CS21);                 // Prescale None = C_FPU / 8 tick frequency\r\n    OCR2A  = samplingInterval;\t\t\t// Set timer top to sampling interval\r\n#if DEBUG\r\n    OCR2A  <<= 1;                       // Reduce sampling frequency by 1/2 in DEBUG (non-optimized) builds to\r\n#endif                                  // avoid starving MIDI dispatch.\r\n    TIMSK2 = _BV(OCIE2A);\r\n}","#ifndef LTC16XX_H_\r\n#define LTC16XX_H_\r\n\r\n#include \"../spi.h\"\r\n\r\ntemplate<PinId csPin>\r\nclass Ltc16xx final {\r\n\tprivate:\r\n\t\tSpi<csPin> _spi;\r\n\t\r\n\tpublic:\r\n\t\tvoid setup() { _spi.setup(); }\r\n\t\r\n\t\tvoid sendHiByte(uint8_t hi) { \r\n\t\t\t_spi.begin();\r\n\t\t\t_spi.unsafe_send(hi);\r\n\t\t}\r\n\t\t\r\n\t\tvoid sendLoByte(uint8_t lo) {\r\n\t\t\t_spi.unsafe_send(lo);\r\n\t\t}\r\n\r\n\t\tvoid end() {\r\n\t\t\t_spi.end();\r\n\t\t\t_spi.unsafe_clearEndOfTransmissionFlag();\r\n\t\t}\r\n};\r\n\r\n#endif /* LTC16XX_H_ */","#ifndef PINS_H_\r\n#define PINS_H_\r\n\r\n#include <avr/io.h>\r\n\r\nenum class PinId {\r\n\tD0 = 0,\r\n\tD1 = 1,\r\n\tD2 = 2,\r\n\tD3 = 3,\r\n\tD4 = 4,\r\n\tD5 = 5,\r\n\tD6 = 6,\r\n\tD7 = 7,\r\n\tD8 = 8,\r\n\tD9 = 9,\r\n\tD10 = 10,\r\n\tD11 = 11,\r\n\tD12 = 12,\r\n\tD13 = 13,\r\n\tA0 = 14,\r\n\tA1 = 15,\r\n\tA2 = 16,\r\n\tA3 = 17,\r\n\tA4 = 18,\r\n\tA5 = 19,\r\n};\r\n\r\ntemplate<PinId pin>\r\nclass Pin {\r\n\tpublic:\r\n\t\tvoid output() __attribute__((always_inline)) {\r\n            switch (pin) {\r\n\t            // PortD\r\n\t            case PinId::D0: DDRD |= _BV(DDD0); break;\r\n\t            case PinId::D1: DDRD |= _BV(DDD1); break;\r\n\t            case PinId::D2: DDRD |= _BV(DDD2); break;\r\n\t            case PinId::D3: DDRD |= _BV(DDD3); break;\r\n\t            case PinId::D4: DDRD |= _BV(DDD4); break;\r\n\t            case PinId::D5: DDRD |= _BV(DDD5); break;\r\n\t            case PinId::D6: DDRD |= _BV(DDD6); break;\r\n\t            case PinId::D7: DDRD |= _BV(DDD7); break;\r\n\r\n\t            // DDRB\r\n\t            case PinId::D8: DDRB |= _BV(DDB0); break;\r\n\t            case PinId::D9: DDRB |= _BV(DDB1); break;\r\n\t            case PinId::D10: DDRB |= _BV(DDB2); break;\r\n\t            case PinId::D11: DDRB |= _BV(DDB3); break;\r\n\t            case PinId::D12: DDRB |= _BV(DDB4); break;\r\n\t            case PinId::D13: DDRB |= _BV(DDB5); break;\r\n\r\n\t            // DDRC\r\n\t            case PinId::A0: DDRC |= _BV(DDC0); break;\r\n\t            case PinId::A1: DDRC |= _BV(DDC1); break;\r\n\t            case PinId::A2: DDRC |= _BV(DDC2); break;\r\n\t            case PinId::A3: DDRC |= _BV(DDC3); break;\r\n\t            case PinId::A4: DDRC |= _BV(DDC4); break;\r\n\t            case PinId::A5: DDRC |= _BV(DDC5); break;\r\n            }\r\n\t\t}\r\n\r\n\t\tvoid high() __attribute__((always_inline)) {\r\n\t\t\tswitch (pin) {\r\n\t\t\t\t// PortD\r\n\t\t\t\tcase PinId::D0: PORTD |= _BV(PORTD0); break;\r\n\t\t\t\tcase PinId::D1: PORTD |= _BV(PORTD1); break;\r\n\t\t\t\tcase PinId::D2: PORTD |= _BV(PORTD2); break;\r\n\t\t\t\tcase PinId::D3: PORTD |= _BV(PORTD3); break;\r\n\t\t\t\tcase PinId::D4: PORTD |= _BV(PORTD4); break;\r\n\t\t\t\tcase PinId::D5: PORTD |= _BV(PORTD5); break;\r\n\t\t\t\tcase PinId::D6: PORTD |= _BV(PORTD6); break;\r\n\t\t\t\tcase PinId::D7: PORTD |= _BV(PORTD7); break;\r\n\r\n\t\t\t\t// PortB\r\n\t\t\t\tcase PinId::D8: PORTB |= _BV(PORTB0); break;\r\n\t\t\t\tcase PinId::D9: PORTB |= _BV(PORTB1); break;\r\n\t\t\t\tcase PinId::D10: PORTB |= _BV(PORTB2); break;\r\n\t\t\t\tcase PinId::D11: PORTB |= _BV(PORTB3); break;\r\n\t\t\t\tcase PinId::D12: PORTB |= _BV(PORTB4); break;\r\n\t\t\t\tcase PinId::D13: PORTB |= _BV(PORTB5); break;\r\n\r\n\t\t\t\t// PortC\r\n\t\t\t\tcase PinId::A0: PORTC |= _BV(PORTC0); break;\r\n\t\t\t\tcase PinId::A1: PORTC |= _BV(PORTC1); break;\r\n\t\t\t\tcase PinId::A2: PORTC |= _BV(PORTC2); break;\r\n\t\t\t\tcase PinId::A3: PORTC |= _BV(PORTC3); break;\r\n\t\t\t\tcase PinId::A4: PORTC |= _BV(PORTC4); break;\r\n\t\t\t\tcase PinId::A5: PORTC |= _BV(PORTC5); break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid low() __attribute__((always_inline)) {\r\n            switch (pin) {\r\n\t            // PortD\r\n\t            case PinId::D0: PORTD &= ~_BV(PORTD0); break;\r\n\t            case PinId::D1: PORTD &= ~_BV(PORTD1); break;\r\n\t            case PinId::D2: PORTD &= ~_BV(PORTD2); break;\r\n\t            case PinId::D3: PORTD &= ~_BV(PORTD3); break;\r\n\t            case PinId::D4: PORTD &= ~_BV(PORTD4); break;\r\n\t            case PinId::D5: PORTD &= ~_BV(PORTD5); break;\r\n\t            case PinId::D6: PORTD &= ~_BV(PORTD6); break;\r\n\t            case PinId::D7: PORTD &= ~_BV(PORTD7); break;\r\n\r\n\t            // PortB\r\n\t            case PinId::D8: PORTB &= ~_BV(PORTB0); break;\r\n\t            case PinId::D9: PORTB &= ~_BV(PORTB1); break;\r\n\t            case PinId::D10: PORTB &= ~_BV(PORTB2); break;\r\n\t            case PinId::D11: PORTB &= ~_BV(PORTB3); break;\r\n\t            case PinId::D12: PORTB &= ~_BV(PORTB4); break;\r\n\t            case PinId::D13: PORTB &= ~_BV(PORTB5); break;\r\n\r\n\t            // PortC\r\n\t            case PinId::A0: PORTC &= ~_BV(PORTC0); break;\r\n\t            case PinId::A1: PORTC &= ~_BV(PORTC1); break;\r\n\t            case PinId::A2: PORTC &= ~_BV(PORTC2); break;\r\n\t            case PinId::A3: PORTC &= ~_BV(PORTC3); break;\r\n\t            case PinId::A4: PORTC &= ~_BV(PORTC4); break;\r\n\t            case PinId::A5: PORTC &= ~_BV(PORTC5); break;\r\n            }\r\n\t\t}\r\n};\r\n\r\n#endif /* PINS_H_ */\r\n","#ifndef SPI_H_\r\n#define SPI_H_\r\n\r\n#include \"pin.h\"\r\n\r\ntemplate<PinId csPin>\r\nclass Spi final {\r\n\tprivate:\r\n\t\tPin<csPin> _csPin;\r\n\t\r\n\tpublic:\r\n\t\tvoid setup() {\r\n\t\t\t_csPin.high();\r\n\t\t\t_csPin.output();\r\n\t\t\t\r\n\t\t\tSPSR |= _BV(SPI2X);                 // SCK = F_CPU/2\r\n\t\t\tSPCR = _BV(SPE) | _BV(MSTR);        // Enable SPI, Master\r\n\t\t\t\r\n\t\t\tDDRB |= _BV(DDB5) | _BV(DDB3);      // Set MOSI and SCK as outputs after enabling SPI.\r\n\t\t}\r\n\t\r\n\t\tvoid begin() {\r\n\t\t\t_csPin.low();\r\n\t\t}\r\n\t\t\r\n\t\tvoid end() {\r\n\t\t\t_csPin.high();\r\n\t\t}\r\n\t\r\n\t\tvoid flush() __attribute__((always_inline)) {\n\t\t\twhile (!(SPSR & _BV(SPIF)));\n\t\t}\n\t\t\n\t\tvoid unsafe_clearEndOfTransmissionFlag() __attribute__((always_inline)) {\n\t\t\tSPSR;\n\t\t}\n\t\r\n\t\tvoid unsafe_send(uint8_t data) __attribute__((always_inline)) {\n\t\t\tSPDR = data;\n\t\t}\n\t\r\n\t\tvoid send(const uint8_t data) __attribute__((always_inline)) {\n\t\t\tflush();\n\t\t\tunsafe_send(data);\n\t\t}\n};\r\n\r\n#endif /* SPI_H_ */","#ifndef __SYNTH_H__\n#define __SYNTH_H__\n\n#include <avr/interrupt.h>\n#include <stdint.h>\n#include \"instruments.h\"\n\n#define DAC\n\n#ifdef __EMSCRIPTEN__\n\t#define DAC\n\tvoid TIMER2_COMPA_vect();\n#endif\n\nclass Synth {\n    public:\n        constexpr static uint8_t numVoices = 16;\n        constexpr static uint8_t maxVoice = Synth::numVoices - 1;\n\t\tconstexpr static uint8_t samplingInterval = 0x65;\n\t\tconstexpr static double sampleRate = static_cast<double>(F_CPU) / 8.0 / static_cast<double>(Synth::samplingInterval);\n\n        void begin();\n        uint8_t getNextVoice();\n        void noteOn(uint8_t voice, uint8_t note, uint8_t velocity, const Instrument& instrument);\n        void noteOff(uint8_t voice);\n        void pitchBend(uint8_t voice, int16_t value);\n        uint8_t getAmp(uint8_t voice);\n        \n        // Suspends audio processing ISR.  While suspended, it is safe to update of volatile state\n        // shared with the ISR and to communicate with other SPI devices.\n        void suspend() __attribute__((always_inline)) {\n            cli();\n            TIMSK2 = 0;\n            sei();\n        }\n        \n        // Resumes audio processing ISR.\n        void resume() __attribute__((always_inline)) {\n            TIMSK2 = _BV(OCIE2A);\n        }\n        \n#ifdef __EMSCRIPTEN__\n\t\tInstrument instrument0;\n\n\t\tvoid noteOnEm(uint8_t voice, uint8_t note, uint8_t velocity, uint8_t instrumentIndex) {\n\t\t\tInstruments::getInstrument(instrumentIndex, instrument0);\n\t\t\tthis->noteOn(voice, note, velocity, instrument0);\n\t\t}\n\t\t\n\t\tuint16_t sample();\n#endif // __EMSCRIPTEN__\n};\n\n#endif // __SYNTH_H__","#include <avr/pgmspace.h>\n#include \"instruments.h\"\n#include \"instruments_generated.h\"\n\ntemplate <typename T> void PROGMEM_readAnything(const T* src, T& dest) {\n    memcpy_P(&dest, src, sizeof(T));\n}\n\nvoid Instruments::getInstrument(uint8_t index, Instrument& instrument) {\n    PROGMEM_readAnything(&instruments[index], instrument);\n}\n\nuint8_t Instruments::getPercussionNote(uint8_t index) {\n    return pgm_read_byte(&percussionNotes[index]);\n}\n\nvoid Instruments::getLerpProgram(uint8_t programIndex, LerpProgram& program) {\n\tPROGMEM_readAnything(&LerpPrograms[programIndex], program);\n}\n\nvoid Instruments::getLerpStage(const LerpStage* pStart, uint8_t stageIndex, LerpStage& stage) {\n\tPROGMEM_readAnything(pStart + stageIndex, stage);\n}\n\n#ifdef __EMSCRIPTEN__\n\nconst HeapRegion<uint8_t> Instruments::getPercussionNotes() {\n\treturn HeapRegion<uint8_t>(&percussionNotes[0], sizeof(percussionNotes));\n}\n\nconst HeapRegion<int8_t> Instruments::getWavetable() {\n    return HeapRegion<int8_t>(&Waveforms[0], sizeof(Waveforms));\n}\n\nconst HeapRegion<LerpProgram> Instruments::getLerpPrograms() {\n\treturn HeapRegion<LerpProgram>(&LerpPrograms[0], sizeof(LerpPrograms));\n}\n\nconst HeapRegion<LerpStage> Instruments::getLerpStages() {\n\treturn HeapRegion<LerpStage>(&LerpStages[0], sizeof(LerpStages));\n}\n\nconst HeapRegion<Instrument> Instruments::getInstruments() {\n\treturn HeapRegion<Instrument>(&instruments[0], sizeof(instruments));\n}\n\n#endif // __EMSCRIPTEN__","#ifndef __INSTRUMENT_H__\n#define __INSTRUMENT_H__\n\nstruct LerpStage {\n\tint16_t slope;\n\tint8_t limit;\n};\n\nstruct LerpProgram {\n\tconst LerpStage* start;\n\tuint8_t initialValue;\n\tuint8_t loopStartAndEnd;\n};\n\n#ifdef __EMSCRIPTEN__\n\n#include <stddef.h>\n\ntemplate<typename T> \nstruct HeapRegion {\n\tsize_t start;\n\tsize_t end;\n\tsize_t itemSize;\n\n\tHeapRegion() {}\n\t\n\tHeapRegion(const T* pStart, const size_t length) {\n\t\tstart = reinterpret_cast<size_t>(pStart);\n\t\tend = start + length;\n\t\titemSize = sizeof(T);\n\t}\n};\n#endif\n\nenum InstrumentFlags : uint8_t {\n    InstrumentFlags_None\t\t\t\t= 0,\n    InstrumentFlags_Noise\t\t\t\t= (1 << 0),\n    InstrumentFlags_HalfAmplitude\t\t= (1 << 1),\n    InstrumentFlags_SelectAmplitude\t\t= (1 << 2),\n    InstrumentFlags_SelectWave\t\t\t= (1 << 3),\n};\n\nstruct Instrument {\n    const int8_t* wave;\n    uint8_t ampMod;\n\tuint8_t freqMod;\n\tuint8_t waveMod;\n    uint8_t xorBits;\n    InstrumentFlags flags;\n};\n\nclass Instruments {\n    public:\n        static void getInstrument(uint8_t index, Instrument& instrument);\n        static uint8_t getPercussionNote(uint8_t index);\n\t\tstatic void getLerpProgram(uint8_t programIndex, LerpProgram& program);\n\t\tstatic void getLerpStage(const LerpStage* pStart, uint8_t stageIndex, LerpStage& stage);\n\n#ifdef __EMSCRIPTEN__\n\t\tstatic const HeapRegion<uint8_t> getPercussionNotes();\n        static const HeapRegion<int8_t> getWavetable();\n\t\tstatic const HeapRegion<LerpProgram> getLerpPrograms();\n\t\tstatic const HeapRegion<LerpStage> getLerpStages();\n\t\tstatic const HeapRegion<Instrument> getInstruments();\n#endif // __EMSCRIPTEN__\n};\n\n#endif // __INSTRUMENT_H__\n","#include <avr/interrupt.h>\r\n#include <avr/io.h>\r\n#include \"midi.h\"\r\n\r\nconstexpr uint8_t maxMidiData = 32;\r\nRingBuffer<uint8_t, /* Log2Capacity: */ 6> _midiBuffer;\r\n\r\nextern void noteOn(uint8_t channel, uint8_t note, uint8_t velocity);\r\nextern void noteOff(uint8_t channel, uint8_t note);\r\nextern void controlChange(uint8_t channel, uint8_t data1, uint8_t data2);\r\nextern void pitchBend(uint8_t channel, int16_t value);\r\nextern void programChange(uint8_t channel, uint8_t program);\r\nextern void sysex(uint8_t cbData, uint8_t bytes[]);\r\n\r\nISR(USART_RX_vect) {\r\n    _midiBuffer.enqueue(UDR0);\r\n}\r\n\r\nvoid midi_setup() {\r\n    constexpr uint16_t baud = 31250;\r\n    constexpr uint16_t ubrr = F_CPU / 16 / baud - 1;\r\n\r\n    UBRR0H = static_cast<uint8_t>(ubrr >> 8);                   // 31250 baud\r\n    UBRR0L = static_cast<uint8_t>(ubrr);\r\n\r\n    UCSR0C= (0 << UMSEL00) | (0 << UMSEL01) |                   // async\r\n            (0 << UPM00)   | (0 << UPM01)   |                   // parity none\r\n            (0 << USBS0)   |                                    // 1 stop bits 1\r\n            (0 << UCSZ02)  | (1 << UCSZ01)  | (1 << UCSZ00);    // 8 data bits\r\n\r\n    UCSR0B |= _BV(RXEN0) | _BV(RXCIE0);                         // Enable receive w/interrupt\r\n}\r\n\r\nenum MidiStatus {\r\n    /* 0x8n */ MidiStatus_NoteOff\t\t\t\t= 0,     // 2 data bytes\r\n    /* 0x9n */ MidiStatus_NoteOn\t\t\t\t= 1,     // 2 data bytes\r\n    /* 0xAn */ MidiStatus_PolyKeyPressure\t\t= 2,     // 2 data bytes\r\n    /* 0xBn */ MidiStatus_ControlChange\t\t\t= 3,     // 2 data bytes\r\n    /* 0xCn */ MidiStatus_ProgramChange\t\t\t= 4,     // 1 data bytes\r\n    /* 0xDn */ MidiStatus_ChannelPressure\t\t= 5,     // 1 data bytes\r\n    /* 0xEn */ MidiStatus_PitchBend\t\t\t\t= 6,     // 2 data bytes\r\n    /* 0xFn */ MidiStatus_Extended\t\t\t\t= 7,     // (variable length)\r\n    /* ???  */ MidiStatus_Unknown\t\t\t\t= 8      // (unknown)\r\n};\r\n\r\nint8_t midiStatusToDataLength[] = {\r\n    /* 0x8n: MidiCommand_NoteOff               */ 2,\r\n    /* 0x9n: MidiCommand_NoteOn                */ 2,\r\n    /* 0xAn: MidiCommand_PolyKeyPressure       */ 2,\r\n    /* 0xBn: MidiCommand_ControlChange         */ 2,\r\n    /* 0xCn: MidiCommand_ProgramChange         */ 1,\r\n    /* 0xDn: MidiCommand_ChannelPressure       */ 1,\r\n    /* 0xEn: MidiCommand_PitchBend             */ 2,\r\n    /* 0xFn: MidiCommand_Extended              */ maxMidiData\r\n};\r\n\r\nMidiStatus midiStatus = MidiStatus_Unknown;     // Status of the incoming message\r\nuint8_t midiChannel = 0xFF;                     // Channel of the incoming message\r\nuint8_t midiDataRemaining = 0;                  // Expected number of data bytes remaining \r\nuint8_t midiDataIndex = 0;                      // Location at which next data byte will be written\r\nuint8_t midiData[maxMidiData] = { 0 };          // Buffer containing incoming data bytes\r\n\r\nvoid dispatchCommand() {\r\n\tconst uint8_t midiData0 = midiData[0];\r\n\t\r\n    switch (midiStatus) {\r\n        case MidiStatus_NoteOff: {\r\n            noteOff(midiChannel, midiData0);\r\n            break;\r\n        }\r\n        case MidiStatus_NoteOn: {\r\n            if (midiData[1] == 0) {\r\n                noteOff(midiChannel, midiData0);\r\n            } else {\r\n                noteOn(midiChannel, midiData0, midiData[1]);\r\n            }\r\n            break;\r\n        }\r\n        case MidiStatus_PitchBend: {\r\n            int16_t value = midiData[1];\r\n            value <<= 7;\r\n            value |= midiData0;\r\n            value -= 0x2000;\r\n            pitchBend(midiChannel, value);\r\n            break;\r\n        }\r\n        case MidiStatus_ControlChange: {\r\n            controlChange(midiChannel, midiData0, midiData[1]);\r\n            break;\r\n        }\r\n        case MidiStatus_ProgramChange: {\r\n            programChange(midiChannel, midiData0);\r\n            break;\r\n        }\r\n\r\n        default: { break; }\r\n    }\r\n\t\r\n/* TODO: Handle running status?\t\r\n\tmidiDataRemaining = midiStatusToDataLength[midiStatus];\t\t\t\t// Running Status: reset the midi data buffer for the current midi status\r\n\tmidiDataIndex = 0;\r\n*/\r\n}\r\n\r\nvoid midi_decode_byte(uint8_t nextByte) {\r\n    if (nextByte & 0x80) {\t\t\t\t\t\t\t\t\t\t\t\t\t// If the high bit is set, this is the start of a new message\r\n        if (midiStatus == MidiStatus_Extended) {\t\t\t\t\t\t\t//   If the previous status was an extended message (sysex or real-time)\r\n            sysex(midiDataIndex, midiData);\t\t\t\t\t\t\t\t\t//     the next byte must be 0xF7 (i.e., EOX).  Ignore EOX and dispatch the sysex().\r\n\t\t\tmidiStatus = MidiStatus_Unknown;\t\t\t\t\t\t\t\t//     The following byte must be a status byte beginning the next message.\r\n            return;\r\n        }\r\n        \r\n        midiStatus = static_cast<MidiStatus>((nextByte >> 4) - 8);\r\n        midiDataRemaining = midiStatusToDataLength[midiStatus];\t\t\t\t// Set the expected data bytes for the new message status.\r\n        midiDataIndex = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t// Reset the midi data buffer.\r\n        midiChannel = nextByte & 0x0F;\r\n    } else {\r\n        if (midiDataRemaining > 0) {\t\t\t\t\t// If more data bytes are expected for the current midi status\r\n            midiData[midiDataIndex++] = nextByte;\t\t//\t then copy the next byte into the data buffer\r\n            midiDataRemaining--;\t\t\t\t\t\t//\t   and decrement the remaining data bytes expected.\r\n\t\t\tif (midiDataRemaining == 0) {\t\t\t\t//   If this was the last data byte expected\r\n\t\t\t\tdispatchCommand();\t\t\t\t\t\t//     then dispatch the current command.\r\n\t        }\r\n\t\t}\r\n    }\r\n}\r\n\r\nvoid midi_process() {\r\n    uint8_t received;\r\n    while (_midiBuffer.dequeue(received)) {\r\n        midi_decode_byte(received);\r\n    }\r\n}","#include <emscripten/bind.h>\n#ifdef USE_CXA_DEMANGLE\n#include <../lib/libcxxabi/include/cxxabi.h>\n#endif\n#include <list>\n#include <vector>\n#include <typeinfo>\n#include <algorithm>\n#include <emscripten/emscripten.h>\n#include <emscripten/wire.h>\n#include <climits>\n#include <limits>\n\nusing namespace emscripten;\n\nextern \"C\" {\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\n        if (has_unbound_type_names) {\n#ifdef USE_CXA_DEMANGLE\n            int stat;\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\n            if (stat == 0 && demangled) {\n                return demangled;\n            }\n\n            switch (stat) {\n                case -1:\n                    return strdup(\"<allocation failure>\");\n                case -2:\n                    return strdup(\"<invalid C++ symbol>\");\n                case -3:\n                    return strdup(\"<invalid argument>\");\n                default:\n                    return strdup(\"<unknown error>\");\n            }\n#else\n            return strdup(ti->name());\n#endif\n        } else {\n            char str[80];\n            sprintf(str, \"%p\", reinterpret_cast<const void*>(ti));\n            return strdup(str);\n        }\n    }\n}\n\nnamespace {\n    template<typename T>\n    static void register_integer(const char* name) {\n        using namespace internal;\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\n    }\n\n    template<typename T>\n    static void register_float(const char* name) {\n        using namespace internal;\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\n    }\n\n\n    // matches typeMapping in embind.js\n    enum TypedArrayIndex {\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n    };\n\n    template<typename T>\n    constexpr TypedArrayIndex getTypedArrayIndex() {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type does not map to a typed array\");\n        return std::is_floating_point<T>::value\n            ? (sizeof(T) == 4\n               ? Float32Array\n               : Float64Array)\n            : (sizeof(T) == 1\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\n               : (sizeof(T) == 2\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\n    }\n\n    template<typename T>\n    static void register_memory_view(const char* name) {\n        using namespace internal;\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\n    }\n}\n\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\n    using namespace emscripten::internal;\n\n    _embind_register_void(TypeID<void>::get(), \"void\");\n\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\n\n    register_integer<char>(\"char\");\n    register_integer<signed char>(\"signed char\");\n    register_integer<unsigned char>(\"unsigned char\");\n    register_integer<signed short>(\"short\");\n    register_integer<unsigned short>(\"unsigned short\");\n    register_integer<signed int>(\"int\");\n    register_integer<unsigned int>(\"unsigned int\");\n    register_integer<signed long>(\"long\");\n    register_integer<unsigned long>(\"unsigned long\");\n\n    register_float<float>(\"float\");\n    register_float<double>(\"double\");\n\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\n\n    // Some of these types are aliases for each other. Luckily,\n    // embind.js's _embind_register_memory_view ignores duplicate\n    // registrations rather than asserting, so the first\n    // register_memory_view call for a particular type will take\n    // precedence.\n\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\n\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\n\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\n\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\n#if __SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\n#endif\n}\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\nprotected:\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n"]}