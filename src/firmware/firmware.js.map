{"version":3,"sources":["d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten\\avr\\mocks.cpp","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten\\bindings.cpp","d:\\emsdk\\emscripten\\1.37.35\\system\\include\\emscripten/bind.h","d:\\emsdk\\emscripten\\1.37.35\\system\\include\\emscripten/wire.h","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../lerp.h","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../synth.h","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../midisynth.h","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../instruments.h","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\main.cpp","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\synth.cpp","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/synth.h","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\instruments.cpp","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth/instruments.h","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\midi.cpp","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\lerp.cpp","d:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\ssd1306.cpp","d:\\emsdk\\emscripten\\1.37.35\\system\\lib\\embind\\bind.cpp","d:\\emsdk\\emscripten\\1.37.35\\system\\include\\libcxx\\typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAA;AAAA;AACA;AAAA;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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A;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AbMA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAoCA;AAAA;;;;;AarBA;;;;;AbfA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAAA;;;;;AAAA;;;;;;;;AazBA;;;ACmHA;AAAA;ADnHA;AAAA","file":"d:/gh/my/x/src/firmware/firmware.js","sourcesContent":["/*\r\n * pgmspace.cpp\r\n *\r\n * Created: 2/10/2018 6:39:53 PM\r\n *  Author: danlehen\r\n */ \r\n\r\n#include \"common.h\"\r\n#include \"pgmspace.h\"\r\n\r\nuint8_t DDRB;\r\nuint8_t DDRD;\r\nuint8_t OCR2A;\r\nuint8_t PORTD;\r\nuint8_t SPCR;\r\nuint8_t TCCR2A;\r\nuint8_t TCCR2B;\r\nuint8_t UBRR0H;\r\nuint8_t UBRR0L;\r\nuint8_t UCSR0B;\r\nuint8_t UCSR0C;\r\n\r\nuint8_t PORTB;\r\nuint8_t SPDR;\r\nuint8_t SPSR = 1 << SPIF;\nuint8_t TIMSK2;\r\n\r\nvoid cli() {}\r\nvoid sei() {}\r\n\r\nuint8_t pgm_read_byte(const volatile void* ptr) { return *(reinterpret_cast<const volatile uint8_t*>(ptr)); }\r\nuint16_t pgm_read_word(const volatile void* ptr) { return *(reinterpret_cast<const volatile uint16_t*>(ptr)); }\r\n","#include \"../lerp.h\"\r#include \"../synth.h\"\r#include \"../midi.h\"\r#include \"../midisynth.h\"\r#include \"../instruments.h\"\r\r#include <emscripten/bind.h>\r\r\nusing namespace emscripten;\r\r\nextern uint8_t OCR2A;\r\n\r\nstatic double getSampleRate() {\r\n\treturn static_cast<double>(F_CPU) / 8L / static_cast<double>(Synth::sampleDivider);\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(firmware) {\r\tfunction(\"midi_decode_byte\", &midi_decode_byte);\r\tfunction(\"getWavetable\", &Instruments::getWavetable);\r\n\tfunction(\"getLerpStages\", &Instruments::getLerpStages);\r\n\tfunction(\"getLerpPrograms\", &Instruments::getLerpPrograms);\r\n\tfunction(\"getLerpProgressions\", &Instruments::getLerpProgressions);\r\n\t\r\n\tvalue_object<HeapRegion<int8_t>>(\"I8s\")\r\n\t\t.field(\"start\", &HeapRegion<int8_t>::start)\r\n\t\t.field(\"end\", &HeapRegion<int8_t>::end);\r\n\r\n\tvalue_object<HeapRegion<uint8_t>>(\"U8s\")\r\n\t\t.field(\"start\", &HeapRegion<uint8_t>::start)\r\n\t\t.field(\"end\", &HeapRegion<uint8_t>::end);\r\n\r\n\tvalue_object<HeapRegion<LerpStage>>(\"LerpStages\")\r\n\t\t.field(\"start\", &HeapRegion<LerpStage>::start)\r\n\t\t.field(\"end\", &HeapRegion<LerpStage>::end);\r\n\r\n\tvalue_object<HeapRegion<LerpProgram>>(\"LerpPrograms\")\r\n\t\t.field(\"start\", &HeapRegion<LerpProgram>::start)\r\n\t\t.field(\"end\", &HeapRegion<LerpProgram>::end);\r\n\r\n\t\r\n\t//function(\"getWavetableByteLength\", &Instruments::getWavetableByteLength);\r\n\t//function(\"getLerpStagesAddress\", &Instruments::getLerpStagesAddress, allow_raw_pointer<ret_val>());\r\n\t//function(\"getLerpStagesByteLength\", &Instruments::getLerpStagesByteLength);\r\n\tfunction(\"getSampleRate\", &getSampleRate);\r\n\tclass_<LerpStage>(\"LerpStage\");\r\tclass_<LerpProgram>(\"LerpProgram\");\r\tclass_<Lerp>(\"Lerp\")\r\t\t.constructor<>()\r\t\t.function(\"sample\", &Lerp::sampleEm)\r\t\t.function(\"start\", &Lerp::startEm)\r\t\t.function(\"stop\", &Lerp::stopEm);\r\tclass_<Synth>(\"Synth\")\r\t\t.constructor<>()\r\n\t\t.function(\"sample\", &Synth::sample)\r\n\t\t.function(\"noteOn\", &Synth::noteOnEm)\r\n\t\t.function(\"noteOff\", &Synth::noteOff);\r\n\tclass_<MidiSynth, base<Synth>>(\"MidiSynth\")\r\t\t.constructor<>()\r\t\t.function(\"midiNoteOn\", &MidiSynth::midiNoteOn)\r\t\t.function(\"midiNoteOff\", &MidiSynth::midiNoteOff)\r\t\t.function(\"midiPitchBend\", &MidiSynth::midiPitchBend);\r\n}","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/bind.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void* GenericFunction;\n        typedef void (*VoidFunctionPtr)(void);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            void _embind_register_class_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID fieldType,\n                const void* fieldContext,\n                const char* getterSignature,\n                GenericFunction getter,\n                const char* setterSignature,\n                GenericFunction setter);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                uintptr_t value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        template<typename FieldType>\n        struct GlobalAccess {\n            typedef internal::BindingType<FieldType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n\n            static WireType get(FieldType* context) {\n                return MemberBinding::toWireType(*context);\n            }\n\n            static void set(FieldType* context, WireType value) {\n                *context = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename InstanceType, typename ElementType, int N>\n        value_object& field(const char* fieldName, ElementType (InstanceType::*field)[N]) {\n            using namespace internal;\n\n            typedef std::array<ElementType, N> FieldType;\n            static_assert(sizeof(FieldType) == sizeof(ElementType[N]));\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast   = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, const FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            auto setter = &GlobalAccess<FieldType>::set;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        uintptr_t asGenericValue(T t) {\n            return static_cast<uintptr_t>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            asGenericValue(BT::toWireType(v)));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n\n#endif // ~C++11 version check\n","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/wire.h> requires building with -std=c++11 or newer!\n#else\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                    return &typeid(T);\n#else\n                    static_assert(!has_unbound_type_names,\n                        \"Unbound type names are illegal with RTTI disabled. \"\n                        \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                        \"from the compiler arguments\");\n                    static_assert(!std::is_polymorphic<C>::value,\n                        \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n                }\n\n                return CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                return &typeid(value);\n#else\n                static_assert(!has_unbound_type_names,\n                    \"Unbound type names are illegal with RTTI disabled. \"\n                    \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                    \"from the compiler arguments\");\n                static_assert(!std::is_polymorphic<C>::value,\n                    \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n            }\n            return LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n\n        template<typename T>\n        constexpr bool typeSupportsMemoryView() {\n            return (std::is_floating_point<T>::value &&\n                        (sizeof(T) == 4 || sizeof(T) == 8)) ||\n                    (std::is_integral<T>::value &&\n                        (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type of typed_memory_view is invalid\");\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n\n#endif // ~C++11 version check\n","#ifndef __LERP_H__\r\n#define __LERP_H__\r\n\r\n#include <stdint.h>\r\n\r\n#define min(a,b) ((a)<(b)?(a):(b))\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\n\r\nstruct LerpStage {\r\n\tint16_t slope;\r\n\tint8_t limit;\r\n};\r\n\r\nstruct LerpProgram {\r\n\tuint8_t progressionStart;\r\n\tuint8_t loopStartAndEnd;\r\n};\r\n\r\nclass Lerp {\r\n\tprivate:\r\n\t\tuint8_t progressionStart = 0;\r\n\t\tuint8_t loopStart = 0xFF;\r\n\t\tuint8_t loopEnd = 0xFF;\r\n\t\tuint8_t stageIndex = 0xFF;\r\n\t\tint16_t amp = 0;\r\n\t\tint16_t slope = 0;\r\n\t\tint8_t limit = -128;\r\n\t\r\n\t\tvoid loadStage() volatile;\r\n\t\r\n\tpublic:\r\n\t\tuint8_t sample() volatile {\r\n\t\t\tamp += slope;\r\n\t\t\tint8_t out = amp >> 8;\r\n\r\n\t\t\tconst bool nextStage = (out < 0) ||\r\n\t\t\t\t(slope < 0)\r\n\t\t\t\t\t? out < limit\r\n\t\t\t\t\t: out > limit;\r\n\t\t\r\n\t\t\tif (nextStage) {\r\n\t\t\t\tout = limit;\r\n\t\t\t\tamp = limit << 8;\r\n\t\t\t\tstageIndex = stageIndex == loopEnd\r\n\t\t\t\t\t ? loopStart\r\n\t\t\t\t\t : stageIndex + 1;\r\n\t\t\t\tloadStage();\r\n\t\t\t}\r\n\t\t\r\n\t\t\treturn out;\r\n\t\t}\r\n\t\t\r\n\t\tvoid start(uint8_t program) volatile;\r\n\r\n\t\tvoid stop() volatile {\r\n\t\t\tif (stageIndex < loopEnd) {\r\n\t\t\t\tstageIndex = loopEnd;\r\n\t\t\t\tloadStage();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfriend class Synth;\r\n\t\t\r\n\t\t#ifdef __EMSCRIPTEN__\r\n\r\n\t\tuint8_t sampleEm() { return sample(); }\r\n\t\tvoid startEm(uint8_t program) { start(program); }\r\n\t\tvoid stopEm() { stop(); }\r\n\t\t\r\n\t\t#endif // __EMSCRIPTEN__\r\n};\r\n\r\n#undef min\r\n#undef max\r\n\r\n#endif //__LERP_H__\r\n","#ifndef __SYNTH_H__\r\n#define __SYNTH_H__\r\n\r\n#include <avr/interrupt.h>\r\n#include <stdint.h>\r\n#include \"instruments.h\"\r\n\r\n// Uncomment below #define to use 256B editable wave buffer instead of wavetable in PROGMEM.\r\n//#define WAVE_EDIT\r\n\r\n#define DAC\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\t#define DAC\r\n\tvoid TIMER2_COMPA_vect();\r\n#endif\r\n\r\nclass Synth {\r\n    public:\r\n        constexpr static uint8_t numVoices = 16;\r\n        constexpr static uint8_t maxVoice = Synth::numVoices - 1;\r\n\t\tconstexpr static uint8_t sampleDivider = 0x65;\r\n\r\n        void begin();\r\n        uint8_t getNextVoice();\r\n        void noteOn(uint8_t voice, uint8_t note, uint8_t midiVelocity, const Instrument& instrument);\r\n        void noteOff(uint8_t voice);\r\n        void pitchBend(uint8_t voice, int16_t value);\r\n        bool isIdle(uint8_t voice);\r\n        uint8_t getAmp(uint8_t voice);\r\n        \r\n        // Suspends audio processing ISR.  While suspended, it is safe to update of volatile state\r\n        // shared with the ISR and to communicate with other SPI devices.\r\n        void suspend() __attribute__((always_inline)) {\r\n            cli();\r\n            TIMSK2 = 0;\r\n            sei();\r\n        }\r\n        \r\n        // Resumes audio processing ISR.\r\n        void resume() __attribute__((always_inline)) {\r\n            TIMSK2 = _BV(OCIE2A);\r\n        }\r\n        \r\n        void setWaveform(uint8_t start, uint8_t bytes[], uint8_t length);\r\n\t\r\n#ifdef __EMSCRIPTEN__\r\n\t\tInstrument instrument0;\r\n\r\n\t\tvoid noteOnEm(uint8_t voice, uint8_t note, uint8_t velocity, uint8_t instrumentIndex) {\r\n\t\t\tInstruments::getInstrument(instrumentIndex, instrument0);\r\n\t\t\tthis->noteOn(voice, note, velocity, instrument0);\r\n\t\t}\r\n\t\t\r\n\t\tuint16_t sample();\r\n#endif // __EMSCRIPTEN__\r\n};\r\n\r\n#endif // __SYNTH_H__","#ifndef __MIDISYNTH_H__\r\n#define __MIDISYNTH_H__\r\n\r\n#include <stdint.h>\r#include \"synth.h\"\r\n\r\nclass MidiSynth final : public Synth {\r\n\tprivate:\r\n        constexpr static uint8_t numMidiChannels = 16;\r        constexpr static uint8_t percussionChannel = 9;\r\r\n        uint8_t voiceToNote[numMidiChannels];\r        uint8_t voiceToChannel[numMidiChannels];\r        Instrument channels[16];\r\n\r\n    public:\r\t\tMidiSynth() : Synth() {\r\t\t\tfor (int8_t i = Synth::maxVoice; i >= 0; i--) {\r\t\t\t\tInstruments::getInstrument(0, channels[i]);\r\t\t\t}\r\r\n\t\t\tfor (int8_t i = Synth::maxVoice; i >= 0; i--) {\r\t\t\t\tvoiceToNote[i] = 0xFF;\r\t\t\t\tvoiceToChannel[i] = 0xFF;\r\t\t\t}\r\t\t}\r\r\n\t\tvoid midiNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {\r\t\t\tif (channel == percussionChannel) {\r\t\t\t\tuint8_t index = note - 35;\r\t\t\t\tif (index >= 46) { index = 45; }\r\r\n\t\t\t\tPercussiveInstrument drum;\r\t\t\t\tInstruments::getDrum(index, drum);\r\t\t\t\tnote = drum.note;\r\r\n\t\t\t\tInstruments::getInstrument(0x80 + index, channels[9]);\r\t\t\t}\r\r\n\t\t\tuint8_t voice = getNextVoice();\r\t\t\tconst Instrument& ch = channels[channel];\r\r\n\t\t\tnoteOn(voice, note, velocity, ch);\r\r\n\t\t\tvoiceToNote[voice] = note;\r\t\t\tvoiceToChannel[voice] = channel;\r\t\t}\r\r\n\t\tvoid midiNoteOff(uint8_t channel, uint8_t note)  {\r\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\r\t\t\t\tif (voiceToNote[voice] == note && voiceToChannel[voice] == channel) {\r\t\t\t\t\tnoteOff(voice);\r\t\t\t\t\tvoiceToChannel[voice] = 0xFF;\r\t\t\t\t\tvoiceToNote[voice] = 0xFF;\r\t\t\t\t}\r\t\t\t}\r\t\t}\r\r\n\t\tvoid midiProgramChange(uint8_t channel, uint8_t program) {\r\t\t\tInstruments::getInstrument(program, channels[channel]);\r\t\t}\r\r\n\t\tvoid midiPitchBend(uint8_t midiChannel, int16_t value) {\r\t\t\tfor (int8_t voice = Synth::maxVoice; voice >= 0; voice--) {\r\t\t\t\tif (voiceToChannel[voice] == midiChannel) {\r\t\t\t\t\tpitchBend(voice, value);\r\t\t\t\t}\r\t\t\t}\r\t\t}\r\r\n}; //MidiSynth\r\n\r\n#endif //__MIDISYNTH_H__\r\n","#ifndef __INSTRUMENT_H__\r\n#define __INSTRUMENT_H__\r\n\r\n#include \"lerp.h\"\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\r\n#include <stddef.h>\r\n\r\ntemplate<typename T> \r\nstruct HeapRegion {\r\n\tsize_t start;\r\n\tsize_t end;\r\n\r\n\tHeapRegion() {}\r\n\t\r\n\tHeapRegion(const T* pStart, const size_t length) {\r\n\t\tstart = reinterpret_cast<size_t>(pStart);\r\n\t\tend = start + length;\r\n\t}\r\n};\r\n#endif\r\n\r\nenum InstrumentFlags : uint8_t {\r\n    InstrumentFlags_None = 0,\r\n    InstrumentFlags_Noise         = (1 << 0),\r\n    InstrumentFlags_HalfAmplitude = (1 << 1),\r\n};\r\n\r\nstruct Instrument {\r\n    const int8_t* wave;\r\n    uint8_t ampMod;\r\n\tuint8_t freqMod;\r\n    uint8_t xorBits;\r\n    InstrumentFlags flags;\r\n};\r\n\r\nstruct PercussiveInstrument {\r\n\tuint8_t note;\r\n};\r\n\r\nclass Instruments {\r\n    public:\r\n        static void getInstrument(uint8_t index, Instrument& instrument);\r\n        static void getDrum(uint8_t index, PercussiveInstrument& drum);\r\n\t\tstatic void getLerpProgram(uint8_t programIndex, LerpProgram& program);\r\n\t\tstatic void getLerpStage(uint8_t progStart, uint8_t stageIndex, LerpStage& stage);\r\n\r\n#ifdef __EMSCRIPTEN__\r\n        static const HeapRegion<int8_t> getWavetable();\r\n\t\tstatic const HeapRegion<LerpProgram> getLerpPrograms();\r\n\t\tstatic const HeapRegion<uint8_t> getLerpProgressions();\r\n\t\tstatic const HeapRegion<LerpStage> getLerpStages();\r\n#endif // __EMSCRIPTEN__\r\n};\r\n\r\n#endif // __INSTRUMENT_H__\r\n","﻿#include <stdint.h>\r\n#include \"midi.h\"\r\n#include \"midisynth.h\"\r\n#include \"instruments.h\"\r\n#include \"ssd1306.h\"\r\n\r\n#if X4\r\n#define ATTACK_KNOB 0x07\r\n#define DECAY_KNOB 0x0A\r\n#define SUSTAIN_KNOB 0x0B\r\n#define RELEASE_KNOB 0x5B\r\n#else\r\n#define ATTACK_KNOB 0x47\r\n#define DECAY_KNOB 0x4A\r\n#define SUSTAIN_KNOB 0x54\r\n#define RELEASE_KNOB 0x07\r\n#endif\r\n\r\n#define RECORD_BUTTON 0x19\r\n#define BACK_BUTTON 0x15\r\n#define FORWARD_BUTTON 0x16\r\n#define XOR_KNOB 0x5D\r\n#define WAVE_OFFSET_KNOB 0x0A\r\n\r\nssd1306 display;\r\nbool isEditing = false;\r\n\r\nMidiSynth synth;\r\n\r\nvoid noteOn(uint8_t channel, uint8_t note, uint8_t velocity) {\r\n\tsynth.midiNoteOn(channel, note, velocity);\r\n}\r\n\r\nvoid noteOff(uint8_t channel, uint8_t note) {\r\n\tsynth.midiNoteOff(channel, note);\r\n}\r\n\r\nvoid sysex(uint8_t cbData, uint8_t data[]) {\r\n#if false\r\n    if (data[0] != 0x7D) {\r\n        return;\r\n    }\r\n    \r\n    int8_t inAvailable = 7;\r\n    int8_t outAvailable = 8;\r\n    uint8_t out = 0;\r\n    uint8_t len = 0;\r\n    \r\n    for (uint8_t i = 1; i < cbData;) {\r\n        uint8_t byte = data[i];\r\n\r\n        int8_t shift = outAvailable - inAvailable;\r\n        if (shift > 0) {\r\n            out |= (byte << shift) & 0xFF;\r\n            outAvailable -= inAvailable;\r\n            inAvailable -= inAvailable;\r\n        } else {\r\n            out |= byte >> -shift;\r\n            inAvailable -= outAvailable;\r\n            outAvailable -= outAvailable;\r\n        }\r\n\r\n        if (inAvailable == 0) {\r\n            i++;\r\n            inAvailable = 7;\r\n        }\r\n\r\n        if (outAvailable == 0) {\r\n            data[len++] = out;\r\n            out = 0;\r\n            outAvailable = 8;\r\n        }\r\n    }\r\n\r\n    uint8_t cursor = 0;\r\n    uint8_t sysexCmd = data[cursor++];\r\n    \r\n    if (sysexCmd < 16) {\r\n        synth.setWaveform(sysexCmd * 16, &data[cursor], 16);\r\n    } else {\r\n        switch (sysexCmd) {\r\n            case 0x10: {\r\n                const uint8_t channel = data[cursor++];\r\n                Instrument& instrument = channels[channel];\r\n                instrument.wave = Instruments::getWavetableAddress(static_cast<uint16_t>(data[cursor]) << 8 | data[cursor + 1]);\r\n                cursor += 2;\r\n                for (uint8_t i = 0; i < 4; i++) {\r\n                    instrument.adsr.stages[i].divider = data[cursor++];\r\n                    instrument.adsr.stages[i].slope = data[cursor++];\r\n                    instrument.adsr.stages[i].limit = data[cursor++];\r\n                }\r\n\t\t\t\tinstrument.adsr.idleDivider = 0xFF;\r\n                instrument.xorBits = data[cursor++];\r\n                instrument.flags = static_cast<InstrumentFlags>(data[cursor++]);\r\n            }\r\n        }\r\n    }\r\n#endif\r\n}\r\n\r\n#if false\r\nvoid setWaveform(int8_t delta) {\r\n    channels[0].wave += delta * 64;\r\n}\r\n#endif\r\n\r\nvoid controlChange(uint8_t channel, uint8_t knob, uint8_t value) {\r\n#if false\r\n    if (!isEditing && knob != RECORD_BUTTON) {\r\n        return;\r\n    }\r\n    \r\n    switch(knob) {\r\n        case RECORD_BUTTON:\r\n        if (value == 0x7F) {\r\n            isEditing = !isEditing;\r\n        }\r\n        break;\r\n        case BACK_BUTTON: {\r\n            if (value == 0x7F) {\r\n                setWaveform(-1);\r\n            }\r\n            break;\r\n        }\r\n        case FORWARD_BUTTON: {\r\n            if (value == 0x7F) {\r\n                setWaveform(1);\r\n            }\r\n            break;\r\n        }\r\n        case ATTACK_KNOB: {\r\n            channels[0].adsr.setLimit(ADSRStage_Attack, 0x7F);\r\n            channels[0].adsr.setDuration(ADSRStage_Attack, value);\r\n            break;\r\n        }\r\n        case DECAY_KNOB: {\r\n            channels[0].adsr.setLimit(ADSRStage_Attack, 0x7F);\r\n            channels[0].adsr.setDuration(ADSRStage_Decay, value);\r\n            break;\r\n        }\r\n        case SUSTAIN_KNOB: {\r\n            channels[0].adsr.setLimit(ADSRStage_Decay, value);\r\n            channels[0].adsr.setLimit(ADSRStage_Sustain, value);\r\n            channels[0].adsr.stages[ADSRStage_Sustain].divider = 0x00;\r\n            channels[0].adsr.setDuration(ADSRStage_Sustain, 0);\r\n            break;\r\n        }\r\n        case RELEASE_KNOB: {\r\n            channels[0].adsr.setLimit(ADSRStage_Release, 0);\r\n            channels[0].adsr.setDuration(ADSRStage_Release, value);\r\n            break;\r\n        }\r\n        case XOR_KNOB: {\r\n            channels[0].xorBits = value;\r\n            break;\r\n        }\r\n        /*\r\n        case WAVE_OFFSET_KNOB: {\r\n            channels[0].waveOffset = value << 1;\r\n        }\r\n        */\r\n    }\r\n#endif\t\r\n}\r\n\r\nvoid programChange(uint8_t channel, uint8_t value) {\r\n    synth.midiPitchBend(channel, value);\r\n}\r\n\r\nvoid pitchBend(uint8_t channel, int16_t value) {\r\n\tsynth.midiPitchBend(channel, value);\r\n}\r\n\r\n#include <avr/io.h>\r\n\r\nvoid setup() {   \r\n    midi_setup();\r\n\r\n    display.begin();\r\n    display.reset();\r\n    display.setRegion(0, 127, 0, 7, 0);\r\n    \r\n    synth.begin();\r\n    \r\n    sei();\r\n}\r\n\r\nvoid loop() {\r\n    static uint8_t displayChannel = 0;\r\n\r\n    displayChannel++;\r\n    displayChannel &= 0x0F;\r\n\r\n    const uint8_t y = synth.getAmp(displayChannel);\r\n    const uint8_t x = displayChannel << 3;\r\n    const int8_t page = 7 - (y >> 3);\r\n    midi_process();\r\n    \r\n    synth.suspend();                                // Suspend audio processing ISR so display can use SPI.\r\n    display.select(x, x + 6, 0, 7);             \r\n    synth.resume();\r\n    \r\n    // Set [0 .. page - 1]\r\n    for (int8_t i = page; i > 0; i--) {\r\n        synth.suspend();                            // Suspend audio processing ISR so display can use SPI.\r\n        display.send7(0x00);\r\n        synth.resume();\r\n        midi_process();\r\n    }\r\n\r\n    {\r\n        uint8_t remainder = 7 - (y & 0x07);\r\n        synth.suspend();                            // Suspend audio processing ISR so display can use SPI.\r\n        display.send7(~((1 << remainder) - 1));\r\n        synth.resume();\r\n        midi_process();\r\n    }\r\n\r\n    // Clear [page + 1 .. 7]\r\n    for (int8_t i = 6 - page; i >= 0; i--) {\r\n        synth.suspend();                            // Suspend audio processing ISR so display can use SPI.\r\n        display.send7(0xFF);\r\n        synth.resume();\r\n        midi_process();\r\n    }\r\n}\r\n\r\n#ifndef __EMSCRIPTEN__\r\nint main() {\r\n    setup();\r\n    \r\n    while(true) {\r\n        loop();\r\n    }\r\n    \r\n    return 0;\r\n}\r\n#endif // !__EMSCRIPTEN__","#include <avr/pgmspace.h>\r\n#include <avr/io.h>\r\n#include <avr/common.h>\r\n#include <avr/interrupt.h>\r\n#include <string.h>\r\n\r\n#include \"synth.h\"\r\n#include \"lerp.h\"\r\n\r\n// Map MIDI notes [0..127] to the corresponding Q8.8 sampling interval at ~20 kHz\r\nconstexpr static uint16_t _midiToPitch[] PROGMEM = {\r\n0x001B, 0x001D, 0x001E, 0x0020, 0x0022, 0x0024, 0x0026, 0x0029, 0x002B, 0x002E, 0x0030, 0x0033, 0x0036, 0x0039, 0x003D, 0x0040,\r\n0x0044, 0x0048, 0x004D, 0x0051, 0x0056, 0x005B, 0x0060, 0x0066, 0x006C, 0x0073, 0x0079, 0x0081, 0x0088, 0x0090, 0x0099, 0x00A2,\r\n0x00AC, 0x00B6, 0x00C1, 0x00CC, 0x00D8, 0x00E5, 0x00F3, 0x0101, 0x0111, 0x0121, 0x0132, 0x0144, 0x0158, 0x016C, 0x0182, 0x0199,\r\n0x01B1, 0x01CB, 0x01E6, 0x0203, 0x0221, 0x0242, 0x0264, 0x0289, 0x02AF, 0x02D8, 0x0303, 0x0331, 0x0362, 0x0395, 0x03CC, 0x0406,\r\n0x0443, 0x0484, 0x04C9, 0x0511, 0x055E, 0x05B0, 0x0607, 0x0663, 0x06C4, 0x072B, 0x0798, 0x080B, 0x0886, 0x0908, 0x0991, 0x0A23,\r\n0x0ABD, 0x0B60, 0x0C0E, 0x0CC5, 0x0D87, 0x0E55, 0x0F30, 0x1017, 0x110C, 0x120F, 0x1322, 0x1445, 0x157A, 0x16C1, 0x181B, 0x198A,\r\n0x1B0F, 0x1CAB, 0x1E5F, 0x202D, 0x2217, 0x241E, 0x2644, 0x288B, 0x2AF4, 0x2D82, 0x3036, 0x3314, 0x361E, 0x3955, 0x3CBE, 0x405B,\r\n0x442F, 0x483C, 0x4C88, 0x5115, 0x55E7, 0x5B03, 0x606C, 0x6628, 0x6C3B, 0x72AB, 0x797C, 0x80B6, 0x885D, 0x9079, 0x9910, 0xA22A,\r\n};\r\n\r\nvolatile const int8_t*  v_wave[Synth::numVoices]    = { 0 };        // Starting address of 256b wave table.\r\nvolatile uint16_t       v_phase[Synth::numVoices]   = { 0 };        // Phase accumulator holding the Q8.8 offset of the next sample.\r\nvolatile uint16_t       v_pitch[Synth::numVoices]   = { 0 };        // Q8.8 sampling period, used to advance the '_phase' accumulator.\r\nvolatile int8_t         v_xor[Synth::numVoices]     = { 0 };        // XOR bits applied to each sample (for effect).\r\nvolatile uint8_t        v_amp[Synth::numVoices]     = { 0 };        // 6-bit amplitude scale applied to each sample.\r\nvolatile bool           v_isNoise[Synth::numVoices] = { 0 };        // If true, '_xor' is periodically overwritten with random values.\r\n\r\nvolatile Lerp           v_ampMod[Synth::numVoices]  = {};           // Amplitude modulation\r\nvolatile Lerp           v_freqMod[Synth::numVoices] = {};\t\t\t// Custom modulation\r\nvolatile uint8_t        v_vol[Synth::numVoices]     = { 0 };        // 7-bit volume scalar applied to ADSR output.\r\n\r\nvolatile uint16_t _basePitch[Synth::numVoices]      = { 0 };                            // Original Q8.8 sampling period, prior to modulation, pitch bend, etc.\r\nvolatile uint8_t       _note[Synth::numVoices]      = { 0 };                            // Index of '_basePitch' in the '_pitches' table, used for pitch bend calculation.\r\nvolatile InstrumentFlags _voiceFlags[Synth::numVoices] = { InstrumentFlags_None };      // InstrumentFlags are misc. behavior modifiers.\r\n\r\n#ifdef WAVE_EDIT\r\nuint8_t        v_waveform[256]                      = { 0 };\r\n#endif\r\n\r\n#ifdef __EMSCRIPTEN__\r\nuint16_t retValFromSample;\r\n#endif // __EMSCRIPTEN__\r\n\r\n// Audio output as biased/unsigned (0 signed -> 0x8000).\r\nuint16_t wavOut = 0x8000;\r\n\r\nSIGNAL(TIMER2_COMPA_vect) {\r\n    TIMSK2 = 0;         // Disable timer2 interrupts to prevent reentrancy.\r\n    sei();              // Re-enable interrupts to ensure we do not miss MIDI events.\r\n    \r\n    {\r\n        static uint16_t noise = 0xACE1;                     // 16-bit maximal-period Galois LFSR\r\n        noise = (noise >> 1) ^ (-(noise & 1) & 0xB400);     // https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs\r\n        \r\n        static uint8_t divider = 0;                         // Time division is used to spread lower-frequency / periodic work\r\n        divider++;                                          // across interrupts.\r\n        \r\n        const uint8_t voice = divider & 0x0F;               // Bottom 4 bits of 'divider' selects which voice to perform work on.\r\n        \r\n        if (v_isNoise[voice]) {                              // To avoid needing a large wavetable for noise, we use xor to combine\r\n            v_xor[voice] = static_cast<uint8_t>(noise);      // the a 256B wavetable with samples from the LFSR.\r\n        }\r\n\r\n        const uint8_t fn = divider & 0xF0;                  // Top 4 bits of 'divider' selects which additional work to perform.\r\n        switch (fn) {\r\n\t\t\tcase 0x20: {\r\n\t\t\t\t//int8_t freqMod = (v_freqMod[voice].sample() - 0x40);\r\n\t\t\t\t//v_pitch[voice] = _basePitch[voice] + freqMod;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            case 0x00:\r\n            case 0x50:\r\n\t\t\tcase 0xA0: {                                    // Advance the ADSR and update '_amp' for the current voice.\r\n                uint16_t amp = v_ampMod[voice].sample();\r\n                v_amp[voice] = (amp * v_vol[voice]) >> 8;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Each interrupt, we transmit the previous output to the DAC concurrently with calculating\r\n    // the next wavOut.  This avoids unproductive busy-waiting for SPI to finish.\r\n        \r\n#ifdef DAC    \r\n    PORTB &= ~_BV(DDB2);                                                // Begin transmitting upper 8-bits to DAC.\r\n    SPDR = wavOut >> 8;                                                 \r\n#endif\r\n\r\n    // Macro that advances '_phase[voice]' by the sampling interval '_pitch[voice]' and stores the next 8-bit\r\n    // sample offset as 'offset##voice'.\r\n    #define PHASE(voice) uint8_t offset##voice = ((v_phase[voice] += v_pitch[voice]) >> 8)\r\n\r\n#ifndef WAVE_EDIT\r\n    // Macro that samples the wavetable at the offset '_wave[voice] + offset##voice', and stores as 'sample##voice'.\r\n    #define SAMPLE(voice) int8_t sample##voice = (pgm_read_byte(v_wave[voice] + offset##voice))\r\n#else\r\n    // Macro that samples the 256B wave buffer at offset 'offset##voice', and stores as 'sample##voice'.\r\n    #define SAMPLE(voice) int8_t sample##voice = (v_waveform[offset##voice])\r\n#endif\r\n\r\n    // Macro that applies '_xor[voice]' to 'sample##voice' and multiplies by '_amp[voice]'.\r\n    #define MIX(voice) ((sample##voice ^ v_xor[voice]) * v_amp[voice])\r\n    \r\n    // We The below sampling/mixing code is carefully arranged to allow the compiler to make use of fixed\r\n    // offsets for loads and stores, and to leave temporary calculations in register.\r\n    \r\n    PHASE(0); PHASE(1); PHASE(2); PHASE(3);                             // Advance the Q8.8 phase and calculate the 8-bit offsets into the wavetable.\r\n    PHASE(4); PHASE(5); PHASE(6); PHASE(7);                             // (Load stores should use constant offsets and results should stay in register.)\r\n    \r\n    SAMPLE(0); SAMPLE(1); SAMPLE(2); SAMPLE(3);                         // Sample the wavetables at the offsets calculated above.\r\n    SAMPLE(4); SAMPLE(5); SAMPLE(6); SAMPLE(7);                         // (Samples should stay in register.)\r\n    \r\n    int16_t mix = (MIX(0) + MIX(1) + MIX(2) + MIX(3)) >> 1;             // Apply xor, modulate by amp, and mix.\r\n    mix += (MIX(4) + MIX(5) + MIX(6) + MIX(7)) >> 1;\r\n\r\n#ifdef DAC\r\n    while (!(SPSR & _BV(SPIF)));                                        // SPI transfer should already be finished (i.e., loop exits immediately).\r\n    SPDR = wavOut;                                                      // Begin transmitting the lower 8-bits.\r\n#endif\r\n\r\n    PHASE(8); PHASE(9); PHASE(10); PHASE(11);                           // Advance the Q8.8 phase and calculate the 8-bit offsets into the wavetable.\r\n    PHASE(12); PHASE(13); PHASE(14); PHASE(15);                         // (Load stores should use constant offsets and results should stay in register.)\r\n    \r\n    SAMPLE(8); SAMPLE(9); SAMPLE(10); SAMPLE(11);                       // Sample the wavetables at the offsets calculated above.\r\n    SAMPLE(12); SAMPLE(13); SAMPLE(14); SAMPLE(15);                     // (Samples should stay in register.)\r\n    \r\n    mix += (MIX(8) + MIX(9) + MIX(10) + MIX(11)) >> 1;                  // Apply xor, modulate by amp, and mix.\r\n    mix += (MIX(12) + MIX(13) + MIX(14) + MIX(15)) >> 1;\r\n    \r\n    wavOut = mix + 0x8000;                                              // Store resulting wave output for transmission on next interrupt.\r\n\r\n#ifdef DAC\r\n    while (!(SPSR & _BV(SPIF)));                                        // SPI transfer should already be finished (i.e., loop exits immediately).\r\n    PORTB |= _BV(DDB2);\r\n#else\r\n    wavOut >>= 2;\r\n\r\n    OCR1B = wavOut >> 7;\r\n    OCR1A = wavOut & 0x7F;\r\n#endif\r\n\r\n    TIMSK2 = _BV(OCIE2A);                                               // Restore timer2 interrupts.\r\n}\r\n\r\n#ifdef __EMSCRIPTEN__\r\nuint16_t Synth::sample() {\r\n\tTIMER2_COMPA_vect();\r\n\treturn wavOut;\r\n}\r\n#endif // __EMSCRIPTEN__\r\n\r\n// Returns the next idle voice, if any.  If no voice is idle, uses ADSR stage and amplitude to\r\n// choose the best candidate for note-stealing.\r\nuint8_t Synth::getNextVoice() {\r\n    uint8_t current = maxVoice;   \r\n\tuint8_t currentStage;\r\n\tint8_t currentAmp;\r\n\t\r\n\t{\r\n\t\tconst volatile Lerp& currentMod\t\t= v_ampMod[current];\r\n\t\tcurrentStage = currentMod.stageIndex;\r\n\t\tcurrentAmp = currentMod.amp;\r\n\t}\r\n\r\n    for (int8_t candidate = maxVoice - 1; candidate >= 0; candidate--) {\r\n        const volatile Lerp& candidateMod   = v_ampMod[candidate];\r\n        const uint8_t candidateStage = candidateMod.stageIndex;\r\n        \r\n        if (candidateStage >= currentStage) {                                  // If the currently chosen voice is in a later ADSR stage, keep it.\r\n            if (candidateStage == currentStage) {                              // Otherwise, if both voices are in the same ADSR stage\r\n                const int8_t candidateAmp = candidateMod.amp;                  //   compare amplitudes to determine which voice to steal.\r\n            \r\n                bool selectCandidate = candidateMod.slope > 0                  // If amplitude is increasing...\r\n                    ? candidateAmp >= currentAmp                               //   steal the lower amplitude voice\r\n                    : candidateAmp <= currentAmp;                              //   otherwise the higher amplitude voice\r\n\r\n                if (selectCandidate) {\r\n                    current = candidate;\r\n\t\t\t\t\tcurrentStage = candidateStage;\r\n\t\t\t\t\tcurrentAmp = candidateAmp;\r\n                }\r\n            } else {\r\n                current = candidate;\t\t\t\t\t\t\t\t\t\t\t// Else, if the candidate is in a later ADSR stage, steal it.\r\n\t\t\t\tcurrentStage = candidateStage;\r\n\t\t\t\tcurrentAmp = candidateMod.amp;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return current;\r\n}\r\n\r\nvoid Synth::noteOn(uint8_t voice, uint8_t note, uint8_t midiVelocity, const Instrument& instrument) {\r\n    if (instrument.flags & InstrumentFlags_HalfAmplitude) {\r\n        midiVelocity >>= 1;\r\n    }\r\n    _voiceFlags[voice] = instrument.flags;\r\n    \r\n    bool isNoise = instrument.flags & InstrumentFlags_Noise;\r\n\r\n    _note[voice] = note;\r\n\r\n    uint16_t pitch = pgm_read_word(&_midiToPitch[note]);\r\n#if DEBUG\r\n\tpitch <<= 1;\t\t\t\t\t\t// Reduce sampling frequency by 1/2 in DEBUG (non-optimized) builds to\r\n#endif                                  // avoid starving MIDI dispatch.\r\n    _basePitch[voice] = pitch;\r\n\r\n    // Suspend audio processing before updating state shared with the ISR.\r\n    suspend();\r\n\r\n    v_wave[voice] = instrument.wave;\r\n    v_phase[voice] = 0;\r\n    v_pitch[voice] = pitch;\r\n    v_xor[voice] = instrument.xorBits;\r\n    v_amp[voice] = 0;\r\n    v_isNoise[voice] = isNoise;\r\n    v_vol[voice] = midiVelocity;\r\n    v_ampMod[voice].start(instrument.ampMod);\r\n\tv_freqMod[voice].start(instrument.freqMod);\r\n    \r\n    resume();\r\n}\r\n\r\nvoid Synth::noteOff(uint8_t voice) {\r\n    // Suspend audio processing before updating state shared with the ISR.\r\n    suspend();\r\n    v_ampMod[voice].stop();\r\n    resume();\r\n}\r\n\r\nvoid Synth::pitchBend(uint8_t voice, int16_t value) {\r\n    uint16_t pitch = _basePitch[voice];\r\n    uint16_t hi, lo;\r\n\r\n    if (value > 0) {\r\n        lo = pitch;\r\n        hi = pgm_read_word(&_midiToPitch[_note[voice] + 2]);\r\n    } else {\r\n        lo = pgm_read_word(&_midiToPitch[_note[voice] - 2]);\r\n        hi = pitch;\r\n    }\r\n\r\n    int32_t delta = hi - lo;\r\n    pitch += static_cast<int16_t>((delta * value) / 0x2000);\r\n\r\n    // Suspend audio processing before updating state shared with the ISR.\r\n    suspend();\r\n    v_pitch[voice] = pitch;\r\n    resume();\r\n}\r\n\r\nuint8_t Synth::getAmp(uint8_t voice) {\r\n    return v_amp[voice];\r\n}\r\n\r\nvoid Synth::begin() {\r\n#ifdef DAC\r\n    PORTB |= _BV(DDB2);                 // Set CS pin HIGH\r\n    DDRB |= _BV(DDB2);                  // Set CS pin as output.\r\n    \r\n    SPSR |= _BV(SPI2X);                 // SCK = F_CPU/2\r\n    SPCR = _BV(SPE) | _BV(MSTR);        // Enable SPI, Master\r\n    \r\n    DDRB |= _BV(DDB5) | _BV(DDB3);      // Set MOSI and SCK as outputs after enabling SPI.\r\n#else\r\n    TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(WGM11);    // Toggle OC1A/OC1B on Compare Match, Fast PWM\r\n    TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10);       // Fast PWM, Top ICR1H/L, Prescale None\r\n    ICR1H = 0;\r\n    ICR1L = 0x7F;                                       // Top = 127 (7-bit PWM per output)\r\n    DDRB |= _BV(DDB1) | _BV(DDB2);                      // Output PWM to DDB1 / DDB2\r\n    TIMSK1 = 0;\r\n#endif\r\n\r\n    TCCR2A = _BV(WGM21);                // CTC Mode (Clears timer and raises interrupt when OCR2B reaches OCR2A)\r\n    TCCR2B = _BV(CS21);                 // Prescale None = C_FPU / 8 tick frequency\r\n    OCR2A  = sampleDivider;             // Sample rate\r\n#if DEBUG\r\n    OCR2A  <<= 1;                       // Reduce sampling frequency by 1/2 in DEBUG (non-optimized) builds to\r\n#endif                                  // avoid starving MIDI dispatch.\r\n    TIMSK2 = _BV(OCIE2A);\r\n}\r\n\r\nvoid Synth::setWaveform(uint8_t start, uint8_t bytes[], uint8_t length) {\r\n#ifdef WAVE_EDIT\r\n    memcpy(&v_waveform[start], bytes, length);\r\n#endif\r\n}","#ifndef __SYNTH_H__\r\n#define __SYNTH_H__\r\n\r\n#include <avr/interrupt.h>\r\n#include <stdint.h>\r\n#include \"instruments.h\"\r\n\r\n// Uncomment below #define to use 256B editable wave buffer instead of wavetable in PROGMEM.\r\n//#define WAVE_EDIT\r\n\r\n#define DAC\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\t#define DAC\r\n\tvoid TIMER2_COMPA_vect();\r\n#endif\r\n\r\nclass Synth {\r\n    public:\r\n        constexpr static uint8_t numVoices = 16;\r\n        constexpr static uint8_t maxVoice = Synth::numVoices - 1;\r\n\t\tconstexpr static uint8_t sampleDivider = 0x65;\r\n\r\n        void begin();\r\n        uint8_t getNextVoice();\r\n        void noteOn(uint8_t voice, uint8_t note, uint8_t midiVelocity, const Instrument& instrument);\r\n        void noteOff(uint8_t voice);\r\n        void pitchBend(uint8_t voice, int16_t value);\r\n        bool isIdle(uint8_t voice);\r\n        uint8_t getAmp(uint8_t voice);\r\n        \r\n        // Suspends audio processing ISR.  While suspended, it is safe to update of volatile state\r\n        // shared with the ISR and to communicate with other SPI devices.\r\n        void suspend() __attribute__((always_inline)) {\r\n            cli();\r\n            TIMSK2 = 0;\r\n            sei();\r\n        }\r\n        \r\n        // Resumes audio processing ISR.\r\n        void resume() __attribute__((always_inline)) {\r\n            TIMSK2 = _BV(OCIE2A);\r\n        }\r\n        \r\n        void setWaveform(uint8_t start, uint8_t bytes[], uint8_t length);\r\n\t\r\n#ifdef __EMSCRIPTEN__\r\n\t\tInstrument instrument0;\r\n\r\n\t\tvoid noteOnEm(uint8_t voice, uint8_t note, uint8_t velocity, uint8_t instrumentIndex) {\r\n\t\t\tInstruments::getInstrument(instrumentIndex, instrument0);\r\n\t\t\tthis->noteOn(voice, note, velocity, instrument0);\r\n\t\t}\r\n\t\t\r\n\t\tuint16_t sample();\r\n#endif // __EMSCRIPTEN__\r\n};\r\n\r\n#endif // __SYNTH_H__","#include <avr/pgmspace.h>\r\n#include \"instruments.h\"\r\n#include \"instruments_generated.h\"\r\n\r\nconstexpr static PercussiveInstrument drums[] PROGMEM = {\r\n    /* 35:        Bass Drum 2 */ { /* note: */ 0x00 },\r\n    /* 36:        Bass Drum 1 */ { /* note: */ 0x13 },\r\n    /* 37: Side Stick/Rimshot */ { /* note: */ 0x13 },\r\n    /* 38:       Snare Drum 1 */ { /* note: */ 0x1F },\r\n    /* 39:          Hand Clap */ { /* note: */ 0x13 },\r\n    /* 40:       Snare Drum 2 */ { /* note: */ 0x1F },\r\n    /* 41:          Low Tom 2 */ { /* note: */ 0x0C },\r\n    /* 42:      Closed Hi-hat */ { /* note: */ 0x3C },\r\n    /* 43:          Low Tom 1 */ { /* note: */ 0x0C },\r\n    /* 44:       Pedal Hi-hat */ { /* note: */ 0x3C },\r\n    /* 45:          Mid Tom 2 */ { /* note: */ 0x0C },\r\n    /* 46:        Open Hi-hat */ { /* note: */ 0x3C },\r\n    /* 47:          Mid Tom 1 */ { /* note: */ 0x0C },\r\n    /* 48:         High Tom 2 */ { /* note: */ 0x0C },\r\n    /* 49:     Crash Cymbal 1 */ { /* note: */ 0x3C },\r\n    /* 50:         High Tom 1 */ { /* note: */ 0x0C },\r\n    /* 51:      Ride Cymbal 1 */ { /* note: */ 0x3C },\r\n    /* 52:     Chinese Cymbal */ { /* note: */ 0x3C },\r\n    /* 53:          Ride Bell */ { /* note: */ 0x0C },\r\n    /* 54:         Tambourine */ { /* note: */ 0x3C },\r\n    /* 55:      Splash Cymbal */ { /* note: */ 0x3C },\r\n    /* 56:            Cowbell */ { /* note: */ 0x0C },\r\n    /* 57:     Crash Cymbal 2 */ { /* note: */ 0x3C },\r\n    /* 58:         Vibra Slap */ { /* note: */ 0x0C },\r\n    /* 59:      Ride Cymbal 2 */ { /* note: */ 0x3C },\r\n    /* 60:         High Bongo */ { /* note: */ 0x0C },\r\n    /* 61:          Low Bongo */ { /* note: */ 0x0C },\r\n    /* 62:    Mute High Conga */ { /* note: */ 0x0C },\r\n    /* 63:    Open High Conga */ { /* note: */ 0x0C },\r\n    /* 64:          Low Conga */ { /* note: */ 0x0C },\r\n    /* 65:       High Timbale */ { /* note: */ 0x0C },\r\n    /* 66:        Low Timbale */ { /* note: */ 0x0C },\r\n    /* 67:         High Agogô */ { /* note: */ 0x0C },\r\n    /* 68:          Low Agogô */ { /* note: */ 0x0C },\r\n    /* 69:             Cabasa */ { /* note: */ 0x0C },\r\n    /* 70:            Maracas */ { /* note: */ 0x0C },\r\n    /* 71:      Short Whistle */ { /* note: */ 0x0C },\r\n    /* 72:       Long Whistle */ { /* note: */ 0x0C },\r\n    /* 73:        Short Güiro */ { /* note: */ 0x0C },\r\n    /* 74:         Long Güiro */ { /* note: */ 0x0C },\r\n    /* 75:             Claves */ { /* note: */ 0x0C },\r\n    /* 76:    High Wood Block */ { /* note: */ 0x0C },\r\n    /* 77:     Low Wood Block */ { /* note: */ 0x0C },\r\n    /* 78:         Mute Cuíca */ { /* note: */ 0x0C },\r\n    /* 79:         Open Cuíca */ { /* note: */ 0x0C },\r\n    /* 80:      Mute Triangle */ { /* note: */ 0x0C },\r\n    /* 81:      Open Triangle */ { /* note: */ 0x0C }\r\n};\r\n\r\ntemplate <typename T> void PROGMEM_readAnything(const T* src, T& dest) {\r\n    memcpy_P(&dest, src, sizeof(T));\r\n}\r\n\r\nvoid Instruments::getInstrument(uint8_t index, Instrument& instrument) {\r\n    PROGMEM_readAnything(&instruments[index], instrument);\r\n}\r\n\r\nvoid Instruments::getDrum(uint8_t index, PercussiveInstrument& drum) {\r\n    PROGMEM_readAnything(&drums[index], drum);\r\n}\r\n\r\nvoid Instruments::getLerpProgram(uint8_t programIndex, LerpProgram& program) {\r\n\tPROGMEM_readAnything(&LerpPrograms[programIndex], program);\r\n}\r\n\r\nvoid Instruments::getLerpStage(uint8_t progressionStart, uint8_t stageIndex, LerpStage& stage) {\r\n\tconst uint8_t index = pgm_read_byte(&LerpProgressions[progressionStart + stageIndex]);\r\n\tPROGMEM_readAnything(&LerpStages[index], stage);\r\n}\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\r\nconst HeapRegion<int8_t> Instruments::getWavetable() {\r\n    return HeapRegion<int8_t>(&Waveforms[0], sizeof(Waveforms));\r\n}\r\n\r\nconst HeapRegion<LerpProgram> Instruments::getLerpPrograms() {\r\n\treturn HeapRegion<LerpProgram>(&LerpPrograms[0], sizeof(LerpPrograms));\r\n}\r\n\r\nconst HeapRegion<uint8_t> Instruments::getLerpProgressions() {\r\n\treturn HeapRegion<uint8_t>(&LerpProgressions[0], sizeof(LerpProgressions));\r\n}\r\n\r\nconst HeapRegion<LerpStage> Instruments::getLerpStages() {\r\n\treturn HeapRegion<LerpStage>(&LerpStages[0], sizeof(LerpStages));\r\n}\r\n\r\n#endif // __EMSCRIPTEN__","#ifndef __INSTRUMENT_H__\r\n#define __INSTRUMENT_H__\r\n\r\n#include \"lerp.h\"\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\r\n#include <stddef.h>\r\n\r\ntemplate<typename T> \r\nstruct HeapRegion {\r\n\tsize_t start;\r\n\tsize_t end;\r\n\r\n\tHeapRegion() {}\r\n\t\r\n\tHeapRegion(const T* pStart, const size_t length) {\r\n\t\tstart = reinterpret_cast<size_t>(pStart);\r\n\t\tend = start + length;\r\n\t}\r\n};\r\n#endif\r\n\r\nenum InstrumentFlags : uint8_t {\r\n    InstrumentFlags_None = 0,\r\n    InstrumentFlags_Noise         = (1 << 0),\r\n    InstrumentFlags_HalfAmplitude = (1 << 1),\r\n};\r\n\r\nstruct Instrument {\r\n    const int8_t* wave;\r\n    uint8_t ampMod;\r\n\tuint8_t freqMod;\r\n    uint8_t xorBits;\r\n    InstrumentFlags flags;\r\n};\r\n\r\nstruct PercussiveInstrument {\r\n\tuint8_t note;\r\n};\r\n\r\nclass Instruments {\r\n    public:\r\n        static void getInstrument(uint8_t index, Instrument& instrument);\r\n        static void getDrum(uint8_t index, PercussiveInstrument& drum);\r\n\t\tstatic void getLerpProgram(uint8_t programIndex, LerpProgram& program);\r\n\t\tstatic void getLerpStage(uint8_t progStart, uint8_t stageIndex, LerpStage& stage);\r\n\r\n#ifdef __EMSCRIPTEN__\r\n        static const HeapRegion<int8_t> getWavetable();\r\n\t\tstatic const HeapRegion<LerpProgram> getLerpPrograms();\r\n\t\tstatic const HeapRegion<uint8_t> getLerpProgressions();\r\n\t\tstatic const HeapRegion<LerpStage> getLerpStages();\r\n#endif // __EMSCRIPTEN__\r\n};\r\n\r\n#endif // __INSTRUMENT_H__\r\n","#include <avr/interrupt.h>\r\n#include <avr/io.h>\r\n#include \"midi.h\"\r\n\r\nextern void noteOn(uint8_t channel, uint8_t note, uint8_t velocity);\r\nextern void noteOff(uint8_t channel, uint8_t note);\r\nextern void controlChange(uint8_t channel, uint8_t data1, uint8_t data2);\r\nextern void pitchBend(uint8_t channel, int16_t value);\r\nextern void programChange(uint8_t channel, uint8_t program);\r\nextern void sysex(uint8_t cbData, uint8_t bytes[]);\r\n\r\nRingBuffer<uint8_t> _midiBuffer;\r\n\r\nISR(USART_RX_vect) {\r\n    _midiBuffer.enqueue(UDR0);\r\n}\r\n\r\nvoid midi_setup() {\r\n    constexpr uint16_t baud = 31250;\r    constexpr uint16_t ubrr = F_CPU / 16 / baud - 1;\r\r\n    UBRR0H = static_cast<uint8_t>(ubrr >> 8);                   // 31250 baud\r    UBRR0L = static_cast<uint8_t>(ubrr);\r\r\n    UCSR0C= (0 << UMSEL00) | (0 << UMSEL01) |                   // async\r            (0 << UPM00)   | (0 << UPM01)   |                   // parity none\r            (0 << USBS0)   |                                    // 1 stop bits 1\r            (0 << UCSZ02)  | (1 << UCSZ01)  | (1 << UCSZ00);    // 8 data bits\r\r    UCSR0B |= _BV(RXEN0) | _BV(RXCIE0);                         // Enable receive w/interrupt\r}\r\n\r\nenum MidiCommand {\r\n    /* 0x8n */ MidiCommand_NoteOff              = 0,     // 2 data bytes\r\n    /* 0x9n */ MidiCommand_NoteOn               = 1,     // 2 data bytes\r\n    /* 0xAn */ MidiCommand_PolyPressureChange   = 2,     // 2 data bytes\r\n    /* 0xBn */ MidiCommand_ControlChange        = 3,     // 2 data bytes\r\n    /* 0xCn */ MidiCommand_ProgramChange        = 4,     // 1 data bytes\r\n    /* 0xDn */ MidiCommand_MonoPressureChange   = 5,     // 1 data bytes\r\n    /* 0xEn */ MidiCommand_PitchBend            = 6,     // 2 data bytes\r\n    /* 0xFn */ MidiCommand_Extended             = 7,     // (unknown)\r\n    /* ???  */ MidiCommand_Unknown              = 8      // (unknown)\r\n};\r\n\r\nint8_t midiCommandToDataLength[] = {\r\n    /* 0x8n: MidiCommand_NoteOff               */ 2,\r\n    /* 0x9n: MidiCommand_NoteOn                */ 2,\r\n    /* 0xAn: MidiCommand_PolyPressureChange    */ 2,\r\n    /* 0xBn: MidiCommand_ControlChange         */ 2,\r\n    /* 0xCn: MidiCommand_ProgramChange         */ 1,\r\n    /* 0xDn: MidiCommand_MonoPressureChange    */ 1,\r\n    /* 0xEn: MidiCommand_PitchBend             */ 2,\r\n    /* 0xFn: MidiCommand_Extended              */ 32\r\n};\r\n\r\nMidiCommand midiCmd     = MidiCommand_Unknown;\r\nuint8_t midiChannel = 0xFF;\r\nint8_t midiDataRemaining = -1;\r\nuint8_t midiDataIndex = 0;\r\nuint8_t midiData[32] = { 0 };\r\n\r\nvoid dispatchCommand() {\r\n    switch (midiCmd) {\r\n        case MidiCommand_NoteOff: {\r\n            noteOff(midiChannel, midiData[0]);\r\n            break;\r\n        }\r\n        case MidiCommand_NoteOn: {\r\n            if (midiData[1] == 0) {\r\n                noteOff(midiChannel, midiData[0]);\r\n            } else {\r\n                noteOn(midiChannel, midiData[0], midiData[1]);\r\n            }\r\n            break;\r\n        }\r\n        case MidiCommand_PitchBend: {\r\n            int16_t value = midiData[1];\r\n            value <<= 7;\r\n            value |= midiData[0];\r\n            value -= 0x2000;\r\n            pitchBend(midiChannel, value);\r\n            break;\r\n        }\r\n        case MidiCommand_ControlChange: {\r\n            controlChange(midiChannel, midiData[0], midiData[1]);\r\n            break;\r\n        }\r\n        case MidiCommand_ProgramChange: {\r\n            programChange(midiChannel, midiData[0]);\r\n            break;\r\n        }\r\n\r\n        default: { break; }\r\n    }\r\n}\r\n\r\nvoid midi_decode_byte(uint8_t nextByte) {\r\n    if (nextByte & 0x80) {\r\n        if (midiCmd == MidiCommand_Extended) {\r\n            sysex(midiDataIndex, midiData);\r\n            if (nextByte == 0xF7) {\r\n                return;\r\n            }\r\n        }\r\n        \r\n        MidiCommand cmd = static_cast<MidiCommand>((nextByte >> 4) - 8);\r\n        midiDataIndex = 0;\r\n        midiDataRemaining = midiCommandToDataLength[cmd];\r\n        midiCmd = cmd;\r\n        midiChannel = nextByte & 0x0F;\r\n        return;\r\n    } else {\r\n        if (midiDataRemaining > 0) {\r\n            midiData[midiDataIndex++] = nextByte;\r\n            midiDataRemaining--;\r\n        }\r\n        if (midiDataRemaining == 0) {\r\n            dispatchCommand();\r\n            midiDataRemaining--;\r\n        }\r\n    }\r\n}\r\n\r\nvoid midi_process() {\r\n    uint8_t received;\r\n    while (_midiBuffer.dequeue(received)) {\r\n        midi_decode_byte(received);\r\n    }\r\n}","#include \"lerp.h\"\r\n#include \"instruments.h\"\r\n\r\nvoid Lerp::start(uint8_t programIndex) volatile {\r\n\tLerpProgram program;\r\n\tInstruments::getLerpProgram(programIndex, program);\r\n\t\r\n\tprogressionStart = program.progressionStart;\r\n\tloopStart = program.loopStartAndEnd >> 4;\r\n\tloopEnd = program.loopStartAndEnd & 0x0F;\r\n\r\n\tamp = 0;\r\n\tstageIndex = 0;\r\n\t\r\n\tloadStage();\r\n}\r\n\r\n\r\nvoid Lerp::loadStage() volatile {\r\n\t LerpStage stage;\r\n\t Instruments::getLerpStage(progressionStart, stageIndex, stage);\r\n\t slope = stage.slope;\r\n\t limit = stage.limit;\r\n}","#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <util/delay.h>\n#include \"ssd1306.h\"\n#include \"midi.h\"\n\n// https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf\nenum Command: uint8_t {\n    Command_SetMemAddressMode   = 0x20,         // 00 = Horiz, 01 = Vert, 10 = Page, 11 = Invalid\n    Command_SetDisplayStartLine = 0x40,         // +0..63 to select the start line.\n    Command_SetMultiplexRatio   = 0xA8,         // A[7:0] = Multiplex ratio in the range 16..63\n    Command_SetDisplayClock     = 0xD5,         // A[3:0] = DCLK divide ratio, A[7:4] = Oscillator frequency\n    Command_SetSegmentRemap     = 0xA0,         // +1 maps column 127 to SEG 0\n    Command_SetDisplayOff       = 0xAE,\n    Command_SetDisplayOn        = 0xAF,\n    Command_SetComOutScanDir    = 0xC0,         // Scan from COM0 -> COM[N-1], N = Multiplex Ratio (C8 is reverse)\n    Command_SetDisplayOffset    = 0xD3,\n    Command_SetChargePump       = 0x8D,         // 0x10 - Disable, 0x14 - Enable [See App Note pg 3/6.]\n    Command_SetCOMPins          = 0xDA,         // A[4] = Alternate config, A[5] = Enable Left/Right remap\n    Command_SetContrast         = 0x81,         // A[7:0] = Value (increases to 0xFF, reset = 0x7F)\n    Command_SetPreChargePeriod  = 0xD9,         // A[3:0] = Phase 1 (1..15 DCLK), A[7:4] = Phase 2 (1..15 DCLK)\n    Command_DisplayResume       = 0xA4,         // Resume displaying RAM contents\n    Command_SetNormalDisplay    = 0xA6,         // +1 to invert display\n    Command_DeactivateScroll    = 0x2E,         // Stop scrolling\n    Command_SetVComHDeselectLvl = 0xDB,         // [A6:4] = 00 ~0.65 Vcc, 10 = ~0.77 Vcc, 11 = ~0.83 Vcc\n    Command_SetColumnAddr       = 0x21,\n    Command_SetPageAddr         = 0x22,\n};\n\nssd1306::ssd1306()\n{\n}\n\nvoid ssd1306::begin()\n{\n    PORTD |= _resPin | _dcPin | _csPin;             // Set display RES/DC/CS pins HIGH.\n    DDRD  |= _resPin | _dcPin | _csPin;             // Set display RES/DC/CS pins as output.\n\n    PORTB |= _BV(DDB2);                             // Must also set default SPI CS pin as output, even\n    DDRB |= _BV(DDB2);                              // if we're not using it for the display.\n\n    SPSR |= _BV(SPI2X);                             // SCK = F_CPU/2\n    SPCR = _BV(SPE) | _BV(MSTR);                    // Enable SPI, Master\n    \n    DDRB |= _BV(DDB5) | _BV(DDB3);                  // Set MOSI and SCK as outputs after enabling SPI.\n}\n\nvoid ssd1306::reset()\n{\n    PORTD |= _resPin;\n    _delay_ms(100);\n    PORTD &= ~_resPin;\n    _delay_ms(100);\n    PORTD |= _resPin;\n\n    // Use the same configuration as olikraus's excellent U8G2 library:\n    // https://github.com/olikraus/u8g2/blob/master/csrc/u8x8_d_ssd1306_128x64_noname.c\n\n    beginCommand();\n    send(Command_SetDisplayOff);\n    send(Command_SetDisplayClock);\n    send(0x80);\n    send(Command_SetMultiplexRatio);\n    send(0x3F);\n    send(Command_SetDisplayOffset);\n    send(0x00);\n    send(Command_SetDisplayStartLine);\n    send(Command_SetChargePump);\n    send(0x14);\n    send(Command_SetMemAddressMode);\n    send(0x00);\n#ifndef ROTATE_180\n    send(Command_SetSegmentRemap);\n    send(Command_SetComOutScanDir);\n#else\n    send(Command_SetSegmentRemap | 0x01);\n    send(Command_SetComOutScanDir | 0x08);\n#endif\n    send(Command_SetCOMPins);\n    send(0x12);\n    send(Command_SetContrast);\n    send(0xCF);\n    send(Command_SetPreChargePeriod);\n    send(0xF1);\n    send(Command_SetVComHDeselectLvl);\n    send(0x40);\n    send(Command_DeactivateScroll);\n    send(Command_DisplayResume);\n    send(Command_SetNormalDisplay);\n    send(Command_SetDisplayOn);\n    endCommand();\n}\n\nvoid ssd1306::select(uint8_t minX, uint8_t maxX, uint8_t minPage, uint8_t maxPage) {\n    beginCommand();\n    send(Command_SetColumnAddr);\n    send(minX);\n    send(maxX);\n\n    send(Command_SetPageAddr);\n    send(minPage);\n    send(maxPage);\n    endCommand();\n}\n\nvoid ssd1306::setRegion(uint8_t minX, uint8_t maxX, uint8_t minPage, uint8_t maxPage, uint8_t value) {\n    select(minX, maxX, minPage, maxPage);\n    \n    const uint8_t numX = maxX - minX;\n    const uint8_t numPage = maxPage - minPage;\n        \n    beginData();\n    for (int8_t y = numPage; y >= 0; y--) {\n        for (int8_t x = numX; x >= 0; x--) {\n            send(value);\n        }\n    }\n    endData();\n}\n\nvoid ssd1306::send7(uint8_t value) {\n    beginData();\n    send(value);\n    send(value);\n    send(value);\n    send(value);\n    send(value);\n    send(value);\n    send(value);\n    endData();\n}","#include <emscripten/bind.h>\n#ifdef USE_CXA_DEMANGLE\n#include <../lib/libcxxabi/include/cxxabi.h>\n#endif\n#include <list>\n#include <vector>\n#include <typeinfo>\n#include <algorithm>\n#include <emscripten/emscripten.h>\n#include <emscripten/wire.h>\n#include <climits>\n#include <limits>\n\nusing namespace emscripten;\n\nextern \"C\" {\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\n        if (has_unbound_type_names) {\n#ifdef USE_CXA_DEMANGLE\n            int stat;\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\n            if (stat == 0 && demangled) {\n                return demangled;\n            }\n\n            switch (stat) {\n                case -1:\n                    return strdup(\"<allocation failure>\");\n                case -2:\n                    return strdup(\"<invalid C++ symbol>\");\n                case -3:\n                    return strdup(\"<invalid argument>\");\n                default:\n                    return strdup(\"<unknown error>\");\n            }\n#else\n            return strdup(ti->name());\n#endif\n        } else {\n            char str[80];\n            sprintf(str, \"%p\", reinterpret_cast<const void*>(ti));\n            return strdup(str);\n        }\n    }\n}\n\nnamespace {\n    template<typename T>\n    static void register_integer(const char* name) {\n        using namespace internal;\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\n    }\n\n    template<typename T>\n    static void register_float(const char* name) {\n        using namespace internal;\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\n    }\n\n\n    // matches typeMapping in embind.js\n    enum TypedArrayIndex {\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n    };\n\n    template<typename T>\n    constexpr TypedArrayIndex getTypedArrayIndex() {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type does not map to a typed array\");\n        return std::is_floating_point<T>::value\n            ? (sizeof(T) == 4\n               ? Float32Array\n               : Float64Array)\n            : (sizeof(T) == 1\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\n               : (sizeof(T) == 2\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\n    }\n\n    template<typename T>\n    static void register_memory_view(const char* name) {\n        using namespace internal;\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\n    }\n}\n\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\n    using namespace emscripten::internal;\n\n    _embind_register_void(TypeID<void>::get(), \"void\");\n\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\n\n    register_integer<char>(\"char\");\n    register_integer<signed char>(\"signed char\");\n    register_integer<unsigned char>(\"unsigned char\");\n    register_integer<signed short>(\"short\");\n    register_integer<unsigned short>(\"unsigned short\");\n    register_integer<signed int>(\"int\");\n    register_integer<unsigned int>(\"unsigned int\");\n    register_integer<signed long>(\"long\");\n    register_integer<unsigned long>(\"unsigned long\");\n\n    register_float<float>(\"float\");\n    register_float<double>(\"double\");\n\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\n\n    // Some of these types are aliases for each other. Luckily,\n    // embind.js's _embind_register_memory_view ignores duplicate\n    // registrations rather than asserting, so the first\n    // register_memory_view call for a particular type will take\n    // precedence.\n\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\n\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\n\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\n\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\n#if __SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\n#endif\n}\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\nprotected:\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n"]}