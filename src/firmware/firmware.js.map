{"version":3,"sources":["C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten\\avr\\mocks.cpp","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten\\bindings.cpp","C:\\emsdk\\emscripten\\1.37.33\\system\\include\\emscripten/bind.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../midi.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../instruments.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../synth.h","C:\\emsdk\\emscripten\\1.37.33\\system\\include\\emscripten/wire.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../lerp.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../midisynth.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten\\avr/pgmspace.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../drivers/dac/ltc16xx.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../drivers/dac/../pin.h","C:\\gh\\my\\x\\src\\firmware\\arduino-gm-synth\\emscripten/../drivers/dac/../spi.h","C:\\emsdk\\emscripten\\1.37.33\\system\\lib\\embind\\bind.cpp","C:\\emsdk\\emscripten\\1.37.33\\system\\include\\libcxx\\typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAQA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAaA;;;;;;;;;;;AKYA;AAAA;;;;;;;;AAGA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;;;;APnDA;AAAA;;;;;AAAA;AAAA;;;;;;;;AO/CA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;APwCA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AOPA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;APMA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAoCA;AAAA;;;;;AOrBA;;;;;APfA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAAA;;;;;AAAA;;;;;;;;AOzBA;;;ACmHA;AAAA;ADnHA;AAAA","file":"C:/gh/my/x/src/firmware/firmware.js","sourcesContent":["#include \"common.h\"\n#include \"pgmspace.h\"\n\nuint8_t TCNT1L;\nuint8_t TCNT1H;\nuint8_t OCR0A;\nuint8_t OCR0B;\nuint8_t OCR1A;\nuint8_t OCR1B;\nuint8_t OCR2A;\nuint8_t SPCR;\nuint8_t TCCR2A;\nuint8_t TCCR2B;\nuint8_t UBRR0H;\nuint8_t UBRR0L;\nuint8_t UCSR0B;\nuint8_t UCSR0C;\n\nuint8_t GTCCR;\n\nuint8_t TCCR1B;\nuint8_t TCCR1A;\n\nuint8_t PORTB;\nuint8_t SPDR;\nuint8_t SPSR = 1 << SPIF;\nuint8_t TIMSK2;\n\nvoid cli() {}\nvoid sei() {}\n\nuint8_t pgm_read_byte(const volatile void* ptr) { return *(reinterpret_cast<const volatile uint8_t*>(ptr)); }\nuint16_t pgm_read_word(const volatile void* ptr) { return *(reinterpret_cast<const volatile uint16_t*>(ptr)); }","#include <emscripten/bind.h>\r\r\n#define DAC Ltc16xx<PinId::D10>\r\n\r#include \"../lerp.h\"\r#include \"../synth.h\"\r#include \"../midi.h\"\r#include \"../midisynth.h\"\r#include \"../instruments.h\"\r\rusing namespace emscripten;\r\r\nMidiSynth synth;\r\n\r\nvoid noteOn(uint8_t channel, uint8_t note, uint8_t velocity)\t\t    { synth.midiNoteOn(channel, note, velocity); }\r\nvoid noteOff(uint8_t channel, uint8_t note)\t\t\t\t\t\t\t            { synth.midiNoteOff(channel, note); }\r\nvoid sysex(uint8_t cbData, uint8_t data[])\t\t\t\t\t\t\t            { }\r\nvoid controlChange(uint8_t channel, uint8_t control, uint8_t value) { synth.midiControlChange(channel, control, value); }\r\nvoid programChange(uint8_t channel, uint8_t value)\t\t\t\t\t        { synth.midiProgramChange(channel, value); }\r\nvoid pitchBend(uint8_t channel, int16_t value)\t\t\t\t\t\t          { synth.midiPitchBend(channel, value); }\r\n\r\nstatic MidiSynth* getSynth()  { return &synth; }\r\nstatic double getSampleRate() { return Synth::sampleRate; }\r\n\r\nEMSCRIPTEN_BINDINGS(firmware) {\r  function(\"midi_decode_byte\", &Midi::decode);\r  function(\"getPercussionNotes\", &Instruments::getPercussionNotes);\r\n  function(\"getWavetable\", &Instruments::getWavetable);\r\n  function(\"getLerpStages\", &Instruments::getLerpStages);\r\n  function(\"getLerpPrograms\", &Instruments::getLerpPrograms);\r\n  function(\"getInstruments\", &Instruments::getInstruments);\r\n  function(\"sample\", &Synth::isr);\r\n  \r\n  value_object<HeapRegion<int8_t>>(\"I8s\")\r\n    .field(\"start\", &HeapRegion<int8_t>::start)\r\n    .field(\"end\", &HeapRegion<int8_t>::end)\r\n    .field(\"itemSize\", &HeapRegion<int8_t>::itemSize);\r\n\r\n  value_object<HeapRegion<uint8_t>>(\"U8s\")\r\n    .field(\"start\", &HeapRegion<uint8_t>::start)\r\n    .field(\"end\", &HeapRegion<uint8_t>::end)\r\n    .field(\"itemSize\", &HeapRegion<uint8_t>::itemSize);\r\n\r\n  value_object<HeapRegion<LerpStage>>(\"LerpStages\")\r\n    .field(\"start\", &HeapRegion<LerpStage>::start)\r\n    .field(\"end\", &HeapRegion<LerpStage>::end)\r\n    .field(\"itemSize\", &HeapRegion<LerpStage>::itemSize);\r\n\r\n  value_object<HeapRegion<LerpProgram>>(\"LerpPrograms\")\r\n    .field(\"start\", &HeapRegion<LerpProgram>::start)\r\n    .field(\"end\", &HeapRegion<LerpProgram>::end)\r\n    .field(\"itemSize\", &HeapRegion<LerpProgram>::itemSize);\r\n\r\n  value_object<HeapRegion<Instrument>>(\"Instruments\")\r\n    .field(\"start\", &HeapRegion<Instrument>::start)\r\n    .field(\"end\", &HeapRegion<Instrument>::end)\r\n    .field(\"itemSize\", &HeapRegion<Instrument>::itemSize);\r\n  \r\n  function(\"getSampleRate\", &getSampleRate);\r\n  function(\"getSynth\", &getSynth, allow_raw_pointer<ret_val>());\r\n  class_<LerpStage>(\"LerpStage\");\r  class_<LerpProgram>(\"LerpProgram\");\r  class_<Instrument>(\"Instrument\");\r  class_<Lerp>(\"Lerp\")\r    .constructor<>()\r    .function(\"sample\", &Lerp::sampleEm)\r    .function(\"start\", &Lerp::startEm)\r    .function(\"stop\", &Lerp::stopEm)\r    .function(\"getStageIndex\", &Lerp::getStageIndex);\r  class_<Synth>(\"Synth\")\r    .constructor<>()\r\n    .function(\"noteOn\", &Synth::noteOnEm)\r\n    .function(\"noteOff\", &Synth::noteOff);\r\n  class_<MidiSynth, base<Synth>>(\"MidiSynth\")\r    .constructor<>()\r    .function(\"midiNoteOn\", &MidiSynth::midiNoteOn)\r    .function(\"midiNoteOff\", &MidiSynth::midiNoteOff)\r    .function(\"midiProgramChange\", &MidiSynth::midiProgramChange)\r    .function(\"midiPitchBend\", &MidiSynth::midiPitchBend);\r\n}","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/bind.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void* GenericFunction;\n        typedef void (*VoidFunctionPtr)(void);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            void _embind_register_class_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID fieldType,\n                const void* fieldContext,\n                const char* getterSignature,\n                GenericFunction getter,\n                const char* setterSignature,\n                GenericFunction setter);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                uintptr_t value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        template<typename FieldType>\n        struct GlobalAccess {\n            typedef internal::BindingType<FieldType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n\n            static WireType get(FieldType* context) {\n                return MemberBinding::toWireType(*context);\n            }\n\n            static void set(FieldType* context, WireType value) {\n                *context = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename InstanceType, typename ElementType, int N>\n        value_object& field(const char* fieldName, ElementType (InstanceType::*field)[N]) {\n            using namespace internal;\n\n            typedef std::array<ElementType, N> FieldType;\n            static_assert(sizeof(FieldType) == sizeof(ElementType[N]));\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast   = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, const FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            auto setter = &GlobalAccess<FieldType>::set;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        uintptr_t asGenericValue(T t) {\n            return static_cast<uintptr_t>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            asGenericValue(BT::toWireType(v)));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n\n#endif // ~C++11 version check\n","#ifndef __MIDI_H__\n#define __MIDI_H__\n\n#include <avr/interrupt.h>\n#include <avr/io.h>\n#include \"ringbuffer.h\"\n\nextern void noteOn(uint8_t channel, uint8_t note, uint8_t velocity);\nextern void noteOff(uint8_t channel, uint8_t note);\nextern void controlChange(uint8_t channel, uint8_t data1, uint8_t data2);\nextern void pitchBend(uint8_t channel, int16_t value);\nextern void programChange(uint8_t channel, uint8_t program);\nextern void sysex(uint8_t cbData, uint8_t bytes[]);\n\nenum MidiStatus : uint8_t {\n  /* 0x8n */ MidiStatus_NoteOff\t\t\t\t    = 0,     // 2 data bytes\n  /* 0x9n */ MidiStatus_NoteOn\t\t\t\t    = 1,     // 2 data bytes\n  /* 0xAn */ MidiStatus_PolyKeyPressure\t\t= 2,     // 2 data bytes\n  /* 0xBn */ MidiStatus_ControlChange\t\t\t= 3,     // 2 data bytes\n  /* 0xCn */ MidiStatus_ProgramChange\t\t\t= 4,     // 1 data bytes\n  /* 0xDn */ MidiStatus_ChannelPressure\t\t= 5,     // 1 data bytes\n  /* 0xEn */ MidiStatus_PitchBend\t\t\t\t  = 6,     // 2 data bytes\n  /* 0xFn */ MidiStatus_Extended\t\t\t\t  = 7,     // (variable length)\n  /* ???  */ MidiStatus_Unknown\t\t\t\t    = 8      // (unknown)\n};\n\nclass Midi final {\n  private:\n    static constexpr uint8_t maxMidiData = 32;\n    static RingBuffer<uint8_t, /* Log2Capacity: */ 6> _midiBuffer;\n\n    static constexpr int8_t midiStatusToDataLength[] = {\n      /* 0x8n: MidiCommand_NoteOff               */ 2,\n      /* 0x9n: MidiCommand_NoteOn                */ 2,\n      /* 0xAn: MidiCommand_PolyKeyPressure       */ 2,\n      /* 0xBn: MidiCommand_ControlChange         */ 2,\n      /* 0xCn: MidiCommand_ProgramChange         */ 1,\n      /* 0xDn: MidiCommand_ChannelPressure       */ 1,\n      /* 0xEn: MidiCommand_PitchBend             */ 2,\n      /* 0xFn: MidiCommand_Extended              */ maxMidiData\n    };\n\n    static MidiStatus midiStatus;\t\t\t      // Status of the incoming message\n    static uint8_t midiChannel;             // Channel of the incoming message\n    static uint8_t midiDataRemaining;       // Expected number of data bytes remaining\n    static uint8_t midiDataIndex;           // Location at which next data byte will be written\n    static uint8_t midiData[maxMidiData];   // Buffer containing incoming data bytes\n  \n    static void dispatchCommand() {\n      const uint8_t midiData0 = midiData[0];\n    \n      switch (midiStatus) {\n        case MidiStatus_NoteOff: {\n          noteOff(midiChannel, midiData0);\n          break;\n        }\n        case MidiStatus_NoteOn: {\n          if (midiData[1] == 0) {\n            noteOff(midiChannel, midiData0);\n            } else {\n            noteOn(midiChannel, midiData0, midiData[1]);\n          }\n          break;\n        }\n        case MidiStatus_PitchBend: {\n          int16_t value = midiData[1];\n          value <<= 7;\n          value |= midiData0;\n          value -= 0x2000;\n          pitchBend(midiChannel, value);\n          break;\n        }\n        case MidiStatus_ControlChange: {\n          controlChange(midiChannel, midiData0, midiData[1]);\n          break;\n        }\n        case MidiStatus_ProgramChange: {\n          programChange(midiChannel, midiData0);\n          break;\n        }\n\n        default: { break; }\n      }\n    \n      /* TODO: Handle running status?\n      midiDataRemaining = midiStatusToDataLength[midiStatus];\t\t\t\t// Running Status: reset the midi data buffer for the current midi status\n      midiDataIndex = 0;\n      */\n    }\n\n  public:\n    static void begin(uint32_t baud) {\n      const uint16_t ubrr = F_CPU / 16 / baud - 1;\n\n      UBRR0H = static_cast<uint8_t>(ubrr >> 8);           // baud\n      UBRR0L = static_cast<uint8_t>(ubrr);\n\n      UCSR0C = (0 << UMSEL00) | (0 << UMSEL01) |          // async\n        (0 << UPM00)   | (0 << UPM01)   |                 // parity none\n        (0 << USBS0)   |                                  // 1 stop bits 1\n        (0 << UCSZ02)  | (1 << UCSZ01)  | (1 << UCSZ00);  // 8 data bits\n\n      UCSR0B |= _BV(RXEN0) | _BV(RXCIE0);                 // Enable receive w/interrupt\n    }\n  \n    static void enqueue(uint8_t byte) {\n      _midiBuffer.enqueue(byte);\n    }\n\n    static void decode(uint8_t byte) {\n      if (byte & 0x80) {\t\t\t\t\t\t\t\t\t\t\t\t\t        // If the high bit is set, this is the start of a new message\n        if (midiStatus == MidiStatus_Extended) {\t\t\t\t\t//   If the previous status was an extended message (sysex or real-time)\n          sysex(midiDataIndex, midiData);\t\t\t\t\t\t\t\t  //     the next byte must be 0xF7 (i.e., EOX).  Ignore EOX and dispatch the sysex().\n          midiStatus = MidiStatus_Unknown;\t\t\t\t\t\t\t  //     The following byte must be a status byte beginning the next message.\n          return;\n        }\n      \n        midiStatus = static_cast<MidiStatus>((byte >> 4) - 8);\n        midiDataRemaining = midiStatusToDataLength[midiStatus];\t\t\t// Set the expected data bytes for the new message status.\n        midiDataIndex = 0;\t\t\t\t\t\t\t\t\t\t\t\t                  // Reset the midi data buffer.\n        midiChannel = byte & 0x0F;\n      } else {\n        if (midiDataRemaining > 0) {\t\t\t\t\t            // If more data bytes are expected for the current midi status\n          midiData[midiDataIndex++] = byte;\t\t\t          //\t then copy the next byte into the data buffer\n          midiDataRemaining--;\t\t\t\t\t\t                //\t   and decrement the remaining data bytes expected.\n          if (midiDataRemaining == 0) {\t\t\t\t            //   If this was the last data byte expected\n            dispatchCommand();\t\t\t\t\t\t                //     then dispatch the current command.\n          }\n        }\n      }\n    }\n\n    static void dispatch() {\n      uint8_t received;\n      while (_midiBuffer.dequeue(received)) {\n        decode(received);\n      }\n    }\n};\n\nMidiStatus Midi::midiStatus = MidiStatus_Unknown;     // Status of the incoming message\nuint8_t Midi::midiChannel = 0xFF;                     // Channel of the incoming message\nuint8_t Midi::midiDataRemaining = 0;                  // Expected number of data bytes remaining\nuint8_t Midi::midiDataIndex = 0;                      // Location at which next data byte will be written\nuint8_t Midi::midiData[maxMidiData] = { 0 };          // Buffer containing incoming data bytes\nconstexpr int8_t Midi::midiStatusToDataLength[];\nRingBuffer<uint8_t, /* Log2Capacity: */ 6> Midi::_midiBuffer;\n\nISR(USART_RX_vect) {\n  Midi::enqueue(UDR0);\n}\n\n#endif // __MIDI_H__","#ifndef __INSTRUMENT_H__\n#define __INSTRUMENT_H__\n\n#include <avr/pgmspace.h>\n\nstruct LerpStage {\n  int16_t slope;\n  int8_t limit;\n};\n\nstruct LerpProgram {\n  const LerpStage* start;\n  uint8_t initialValue;\n  uint8_t loopStartAndEnd;\n};\n\nenum InstrumentFlags : uint8_t {\n  InstrumentFlags_None\t\t\t\t      = 0,\n  InstrumentFlags_Noise\t\t\t\t      = (1 << 0),\n  InstrumentFlags_HalfAmplitude\t\t  = (1 << 1),\n  InstrumentFlags_SelectAmplitude\t\t= (1 << 2),\n  InstrumentFlags_SelectWave\t\t\t  = (1 << 3),\n};\n\nstruct Instrument {\n  const int8_t* wave;\n  uint8_t ampMod;\n  uint8_t freqMod;\n  uint8_t waveMod;\n  uint8_t xorBits;\n  InstrumentFlags flags;\n};\n\ntemplate <typename T> void PROGMEM_copy(const T* src, T& dest) {\n  memcpy_P(&dest, src, sizeof(T));\n}\n\nclass Instruments {\n  private:\n    #include \"instruments_generated.h\"\n\n  public:\n    static void getInstrument(uint8_t index, Instrument& instrument) {\n      PROGMEM_copy(&instruments[index], instrument);\n    }\n\n    static uint8_t getPercussiveInstrument(uint8_t note, Instrument& instrument) {\n      /* TODO: Support additional GS/GM2 percussion\r\n        http://www.voidaudio.net/percussion.html (loads very slowly)\r\n    \r\n        27 High Q\r\n        28 Slap\r\n        29 Scratch Push\r\n        30 Scratch Pull\r\n        31 Sticks\r\n        32 Square Click\r\n        33 Metronome Click\r\n        34 Metronome Bell\r\n        ...\r\n        81 Shaker\r\n        82 Jingle Bell\r\n        83 Belltree\r\n        84 Castanets\r\n        85 Mute Surdo\r\n        86 Open Surdo\r\n        */\r\n\r      uint8_t index = note - 35;\t\t\t\t\t\t\t        // Calculate the the index of the percussion instrument relative\r      if (index > 45) { index = 45; }\t\t\t\t\t        // to the beginning of the percussion instruments (i.e., less 128).\r\r\n      Instruments::getInstrument(0x80 + index,\t\t\t  // Load the percussion instrument\r        instrument);\t\t                              // (Note: percussion instruments begin at 128)\r\n\r\n      return pgm_read_byte(&percussionNotes[index]);  // Return the frequency (i.e., midi note) to play the instrument.\r\n    }\n\n    static void getLerpProgram(uint8_t programIndex, LerpProgram& program) {\n      PROGMEM_copy(&LerpPrograms[programIndex], program);\n    }\n\n    static void getLerpStage(const LerpStage* pStart, uint8_t stageIndex, LerpStage& stage) {\n      PROGMEM_copy(pStart + stageIndex, stage);\n    }\n\n  #ifdef __EMSCRIPTEN__\n    static const HeapRegion<uint8_t> getPercussionNotes() {\n      return HeapRegion<uint8_t>(&percussionNotes[0], sizeof(percussionNotes));\n    }\n\n    static const HeapRegion<int8_t> getWavetable() {\n      return HeapRegion<int8_t>(&Waveforms[0], sizeof(Waveforms));\n    }\n\n    static const HeapRegion<LerpProgram> getLerpPrograms() {\n      return HeapRegion<LerpProgram>(&LerpPrograms[0], sizeof(LerpPrograms));\n    }\n\n    static const HeapRegion<LerpStage> getLerpStages() {\n      return HeapRegion<LerpStage>(&LerpStages[0], sizeof(LerpStages));\n    }\n\n    static const HeapRegion<Instrument> getInstruments() {\n      return HeapRegion<Instrument>(&instruments[0], sizeof(instruments));\n    }\n  #endif // __EMSCRIPTEN__\n};\n\nconstexpr LerpStage Instruments::LerpStages[] PROGMEM;\nconstexpr LerpProgram Instruments::LerpPrograms[] PROGMEM;\nconstexpr Instrument Instruments::instruments[] PROGMEM;\nconstexpr int8_t Instruments::Waveforms[] PROGMEM;\r\nconstexpr uint8_t Instruments::percussionNotes[] PROGMEM;\r\n\n#endif // __INSTRUMENT_H__","#ifndef __SYNTH_H__\r\n#define __SYNTH_H__\r\n\r\n#include <avr/interrupt.h>\r\n#include <avr/pgmspace.h>\r\n#include <stdint.h>\r\n#include \"instruments.h\"\r\n#include \"lerp.h\"\r\n#include \"drivers/dac/ltc16xx.h\"\r\n#include \"drivers/dac/pwm0.h\"\r\n#include \"drivers/dac/pwm1.h\"\r\n#include \"drivers/dac/pwm01.h\"\r\n#include <math.h>\r\n\r\n#ifndef __EMSCRIPTEN__\r\nconstexpr static uint16_t pitch(double sampleRate, double note) {\r\n  return round(pow(2, (note - 69.0) / 12.0) * 440.0 / sampleRate * static_cast<double>(0xFFFF));\r\n}\r\n#endif\r\n\r\nclass Synth {\r\n  public:\r\n    constexpr static uint8_t numVoices = 16;\r\n    constexpr static uint8_t maxVoice = Synth::numVoices - 1;\r\n    constexpr static uint8_t samplingInterval = 0x65\r\n  #if DEBUG\r\n      >> 1\t// On Debug, halve sampling interval to avoid starving MIDI dispatch.\r\n  #endif\r\n      ;\r\n  \r\n  constexpr static double sampleRate = static_cast<double>(F_CPU) / 8.0 / static_cast<double>(Synth::samplingInterval);\r\n  \r\n  private:\r\n    static constexpr uint8_t offsetTable[] = { 0, 0, 1, 1, 2, 3, 3, 3 };\r\n\r\n    // Map MIDI notes [0..127] to the corresponding Q8.8 sampling interval\r\n    constexpr static uint16_t _noteToPitch[] PROGMEM = {\r\n    #ifndef __EMSCRIPTEN__\r\n      pitch(sampleRate, 0x00), pitch(sampleRate, 0x01), pitch(sampleRate, 0x02), pitch(sampleRate, 0x03), pitch(sampleRate, 0x04), pitch(sampleRate, 0x05), pitch(sampleRate, 0x06), pitch(sampleRate, 0x07),\r\n      pitch(sampleRate, 0x08), pitch(sampleRate, 0x09), pitch(sampleRate, 0x0A), pitch(sampleRate, 0x0B), pitch(sampleRate, 0x0C), pitch(sampleRate, 0x0D), pitch(sampleRate, 0x0E), pitch(sampleRate, 0x0F),\r\n      pitch(sampleRate, 0x10), pitch(sampleRate, 0x11), pitch(sampleRate, 0x12), pitch(sampleRate, 0x13), pitch(sampleRate, 0x14), pitch(sampleRate, 0x15), pitch(sampleRate, 0x16), pitch(sampleRate, 0x17),\r\n      pitch(sampleRate, 0x18), pitch(sampleRate, 0x19), pitch(sampleRate, 0x1A), pitch(sampleRate, 0x1B), pitch(sampleRate, 0x1C), pitch(sampleRate, 0x1D), pitch(sampleRate, 0x1E), pitch(sampleRate, 0x1F),\r\n      pitch(sampleRate, 0x20), pitch(sampleRate, 0x21), pitch(sampleRate, 0x22), pitch(sampleRate, 0x23), pitch(sampleRate, 0x24), pitch(sampleRate, 0x25), pitch(sampleRate, 0x26), pitch(sampleRate, 0x27),\r\n      pitch(sampleRate, 0x28), pitch(sampleRate, 0x29), pitch(sampleRate, 0x2A), pitch(sampleRate, 0x2B), pitch(sampleRate, 0x2C), pitch(sampleRate, 0x2D), pitch(sampleRate, 0x2E), pitch(sampleRate, 0x2F),\r\n      pitch(sampleRate, 0x30), pitch(sampleRate, 0x31), pitch(sampleRate, 0x32), pitch(sampleRate, 0x33), pitch(sampleRate, 0x34), pitch(sampleRate, 0x35), pitch(sampleRate, 0x36), pitch(sampleRate, 0x37),\r\n      pitch(sampleRate, 0x38), pitch(sampleRate, 0x39), pitch(sampleRate, 0x3A), pitch(sampleRate, 0x3B), pitch(sampleRate, 0x3C), pitch(sampleRate, 0x3D), pitch(sampleRate, 0x3E), pitch(sampleRate, 0x3F),\r\n      pitch(sampleRate, 0x40), pitch(sampleRate, 0x41), pitch(sampleRate, 0x42), pitch(sampleRate, 0x43), pitch(sampleRate, 0x44), pitch(sampleRate, 0x45), pitch(sampleRate, 0x46), pitch(sampleRate, 0x47),\r\n      pitch(sampleRate, 0x48), pitch(sampleRate, 0x49), pitch(sampleRate, 0x4A), pitch(sampleRate, 0x4B), pitch(sampleRate, 0x4C), pitch(sampleRate, 0x4D), pitch(sampleRate, 0x4E), pitch(sampleRate, 0x4F),\r\n      pitch(sampleRate, 0x50), pitch(sampleRate, 0x51), pitch(sampleRate, 0x52), pitch(sampleRate, 0x53), pitch(sampleRate, 0x54), pitch(sampleRate, 0x55), pitch(sampleRate, 0x56), pitch(sampleRate, 0x57),\r\n      pitch(sampleRate, 0x58), pitch(sampleRate, 0x59), pitch(sampleRate, 0x5A), pitch(sampleRate, 0x5B), pitch(sampleRate, 0x5C), pitch(sampleRate, 0x5D), pitch(sampleRate, 0x5E), pitch(sampleRate, 0x5F),\r\n      pitch(sampleRate, 0x60), pitch(sampleRate, 0x61), pitch(sampleRate, 0x62), pitch(sampleRate, 0x63), pitch(sampleRate, 0x64), pitch(sampleRate, 0x65), pitch(sampleRate, 0x66), pitch(sampleRate, 0x67),\r\n      pitch(sampleRate, 0x68), pitch(sampleRate, 0x69), pitch(sampleRate, 0x6A), pitch(sampleRate, 0x6B), pitch(sampleRate, 0x6C), pitch(sampleRate, 0x6D), pitch(sampleRate, 0x6E), pitch(sampleRate, 0x6F),\r\n      pitch(sampleRate, 0x70), pitch(sampleRate, 0x71), pitch(sampleRate, 0x72), pitch(sampleRate, 0x73), pitch(sampleRate, 0x74), pitch(sampleRate, 0x75), pitch(sampleRate, 0x76), pitch(sampleRate, 0x77),\r\n      pitch(sampleRate, 0x78), pitch(sampleRate, 0x79), pitch(sampleRate, 0x7A), pitch(sampleRate, 0x7B), pitch(sampleRate, 0x7C), pitch(sampleRate, 0x7D), pitch(sampleRate, 0x7E), pitch(sampleRate, 0x7F),\r\n    #else\r\n      // Map MIDI notes [0..127] to the corresponding Q8.8 sampling interval at ~20 kHz\r\n      0x001B, 0x001D, 0x001E, 0x0020, 0x0022, 0x0024, 0x0026, 0x0029, 0x002B, 0x002E, 0x0030, 0x0033, 0x0036, 0x0039, 0x003D, 0x0040,\r\n      0x0044, 0x0048, 0x004D, 0x0051, 0x0056, 0x005B, 0x0060, 0x0066, 0x006C, 0x0073, 0x0079, 0x0081, 0x0088, 0x0090, 0x0099, 0x00A2,\r\n      0x00AC, 0x00B6, 0x00C1, 0x00CC, 0x00D8, 0x00E5, 0x00F3, 0x0101, 0x0111, 0x0121, 0x0132, 0x0144, 0x0158, 0x016C, 0x0182, 0x0199,\r\n      0x01B1, 0x01CB, 0x01E6, 0x0203, 0x0221, 0x0242, 0x0264, 0x0289, 0x02AF, 0x02D8, 0x0303, 0x0331, 0x0362, 0x0395, 0x03CC, 0x0406,\r\n      0x0443, 0x0484, 0x04C9, 0x0511, 0x055E, 0x05B0, 0x0607, 0x0663, 0x06C4, 0x072B, 0x0798, 0x080B, 0x0886, 0x0908, 0x0991, 0x0A23,\r\n      0x0ABD, 0x0B60, 0x0C0E, 0x0CC5, 0x0D87, 0x0E55, 0x0F30, 0x1017, 0x110C, 0x120F, 0x1322, 0x1445, 0x157A, 0x16C1, 0x181B, 0x198A,\r\n      0x1B0F, 0x1CAB, 0x1E5F, 0x202D, 0x2217, 0x241E, 0x2644, 0x288B, 0x2AF4, 0x2D82, 0x3036, 0x3314, 0x361E, 0x3955, 0x3CBE, 0x405B,\r\n      0x442F, 0x483C, 0x4C88, 0x5115, 0x55E7, 0x5B03, 0x606C, 0x6628, 0x6C3B, 0x72AB, 0x797C, 0x80B6, 0x885D, 0x9079, 0x9910, 0xA22A,\r\n    #endif\r\n    };\r\n\r\n    static volatile const int8_t*\tv_wave[Synth::numVoices];\t\t\t  // Starting address of 256b wave table.\r\n    static volatile uint16_t\t\t  v_phase[Synth::numVoices];\t\t\t// Phase accumulator holding the Q8.8 offset of the next sample.\r\n    static volatile uint16_t\t\t  v_pitch[Synth::numVoices];\t\t\t// Q8.8 sampling period, used to advance the '_phase' accumulator.\r\n    static volatile int8_t\t\t\t  v_xor[Synth::numVoices];\t\t\t  // XOR bits applied to each sample (for effect).\r\n    static volatile uint8_t\t\t\t  v_amp[Synth::numVoices];\t\t\t  // 6-bit amplitude scale applied to each sample.\r\n    static volatile bool\t\t\t    v_isNoise[Synth::numVoices];\t\t// If true, '_xor' is periodically overwritten with random values.\r\n\r\n    static volatile Lerp\t\t\t    v_ampMod[Synth::numVoices];     // Amplitude modulation\r\n    static volatile Lerp\t\t\t    v_freqMod[Synth::numVoices];\t\t// Frequency modulation\r\n    static volatile Lerp\t\t\t    v_waveMod[Synth::numVoices];\t\t// Wave offset modulation\r\n\r\n    static volatile uint8_t\t\t\t  v_vol[Synth::numVoices];\t\t\t  // 7-bit volume scalar applied to ADSR output.\r\n\r\n    static volatile uint16_t\t\t  v_basePitch[Synth::numVoices];\t// Original Q8.8 sampling period, prior to modulation, pitch bend, etc.\r\n    static volatile uint16_t\t\t  v_bentPitch[Synth::numVoices];\t// Q8.8 sampling post pitch bend, but prior to freqMod.\r\n    static volatile const int8_t*\tv_baseWave[Synth::numVoices];\t\t// Original starting address in wavetable.\r\n    static volatile uint8_t\t\t\t  _note[Synth::numVoices];\t\t\t  // Index of '_basePitch' in the '_pitches' table, used for pitch bend calculation.\r\n  \r\n    static DAC _dac;\r\n  \r\n  public:\r\n    void begin(){\r\n      _dac.setup();\r\n\r\n      TCCR2A = _BV(WGM21);                // CTC Mode (Clears timer and raises interrupt when OCR2B reaches OCR2A)\r\n      TCCR2B = _BV(CS21);                 // Prescale None = C_FPU / 8 tick frequency\r\n      OCR2A  = samplingInterval;\t\t\t    // Set timer top to sampling interval\r\n      TIMSK2 = _BV(OCIE2A);               // Enable ISR\r\n    }\r\n  \r\n    // Returns the next idle voice, if any.  If no voice is idle, uses ADSR stage and amplitude to\r\n    // choose the best candidate for note-stealing.\r\n    uint8_t getNextVoice() {\r\n      uint8_t current = maxVoice;\r\n      uint8_t currentStage;\r\n      int8_t currentAmp;\r\n    \r\n      {\r\n        const volatile Lerp& currentMod\t= v_ampMod[current];\r\n        currentStage = currentMod.stageIndex;\r\n        currentAmp = currentMod.amp;\r\n      }\r\n\r\n      for (uint8_t candidate = maxVoice - 1; candidate < maxVoice; candidate--) {\r\n        const volatile Lerp& candidateMod = v_ampMod[candidate];\r\n        const uint8_t candidateStage = candidateMod.stageIndex;\r\n      \r\n        if (candidateStage >= currentStage) {                 // If the currently chosen voice is in a later ADSR stage, keep it.\r\n          if (candidateStage == currentStage) {               // Otherwise, if both voices are in the same ADSR stage\r\n            const int8_t candidateAmp = candidateMod.amp;     //   compare amplitudes to determine which voice to prefer.\r\n          \r\n            bool selectCandidate = candidateMod.slope >= 0    // If amplitude is increasing...\r\n              ? candidateAmp >= currentAmp\t\t\t\t\t\t\t      //   prefer the lower amplitude voice\r\n              : candidateAmp <= currentAmp;\t\t\t\t\t\t\t      //   otherwise the higher amplitude voice\r\n\r\n            if (selectCandidate) {\r\n              current = candidate;\r\n              currentStage = candidateStage;\r\n              currentAmp = candidateAmp;\r\n            }\r\n          } else {\r\n            current = candidate;\t\t\t\t\t\t\t\t\t\t          // Else, if the candidate is in a later ADSR stage, prefer it.\r\n            currentStage = candidateStage;\r\n            currentAmp = candidateMod.amp;\r\n          }\r\n        }\r\n      }\r\n    \r\n      return current;\r\n    }\r\n\r\n    void noteOn(uint8_t voice, uint8_t note, uint8_t velocity, const Instrument& instrument) {\r\n      const uint8_t flags = instrument.flags;\r\n      if (flags & InstrumentFlags_HalfAmplitude) {\r\n        velocity >>= 1;\r\n      }\r\n    \r\n      bool isNoise = flags & InstrumentFlags_Noise;\r\n    \r\n      uint8_t noteOffset = offsetTable[note >> 4];\r\n      uint8_t ampOffset = flags & InstrumentFlags_SelectAmplitude\r\n        ? noteOffset\r\n        : 0;\r\n    \r\n      uint8_t waveOffset = flags & InstrumentFlags_SelectWave\r\n        ? noteOffset << 6\r\n        : 0;\r\n    \r\n      _note[voice] = note;\r\n\r\n      uint16_t pitch = pgm_read_word(&_noteToPitch[note]);\r\n\r\n      // Suspend audio processing before updating state shared with the ISR.\r\n      suspend();\r\n\r\n      v_wave[voice] = v_baseWave[voice] = instrument.wave + waveOffset;\r\n      v_phase[voice] = 0;\r\n      v_pitch[voice] = v_bentPitch[voice] = v_basePitch[voice] = pitch;\r\n      v_xor[voice] = instrument.xorBits;\r\n      v_amp[voice] = 0;\r\n      v_isNoise[voice] = isNoise;\r\n      v_vol[voice] = velocity;\r\n      v_ampMod[voice].start(instrument.ampMod + ampOffset);\r\n      v_freqMod[voice].start(instrument.freqMod);\r\n      v_waveMod[voice].start(instrument.waveMod);\r\n    \r\n      resume();\r\n    }\r\n\r\n    void noteOff(uint8_t voice) {\r\n      // Suspend audio processing before updating state shared with the ISR.\r\n      suspend();\r\n      v_ampMod[voice].stop();\r\n      resume();\r\n    }\r\n  \r\n    void pitchBend(uint8_t voice, int16_t value) {\r\n      uint16_t pitch = v_basePitch[voice];\r\n      uint16_t delta = value >= 0\r\n        ? pgm_read_word(&_noteToPitch[_note[voice] + 2]) - pitch\r\n        : pitch - pgm_read_word(&_noteToPitch[_note[voice] - 2]);\r\n\r\n      int32_t product;\r\n\r\n    #ifndef __EMSCRIPTEN__\r\n      // https://mekonik.wordpress.com/2009/03/18/arduino-avr-gcc-multiplication/\r\n      asm volatile (\r\n        \"clr r26 \\n\\t\"\r\n        \"mul %A1, %A2 \\n\\t\"\r\n        \"movw %A0, r0 \\n\\t\"\r\n        \"mulsu %B1, %B2 \\n\\t\"\r\n        \"movw %C0, r0 \\n\\t\"\r\n        \"mul %B2, %A1 \\n\\t\"\r\n        \"add %B0, r0 \\n\\t\"\r\n        \"adc %C0, r1 \\n\\t\"\r\n        \"adc %D0, r26 \\n\\t\"\r\n        \"mulsu %B1, %A2 \\n\\t\"\r\n        \"sbc %D0, r26 \\n\\t\"\r\n        \"add %B0, r0 \\n\\t\"\r\n        \"adc %C0, r1 \\n\\t\"\r\n        \"adc %D0, r26 \\n\\t\"\r\n        \"clr r1 \\n\\t\"\r\n        : \"=&r\" (product)\r\n        : \"a\" (value), \"a\" (delta)\r\n        : \"r26\");\r\n    #else\r\n      product = value * delta;\r\n    #endif\r\n\r\n      pitch += static_cast<int16_t>(product / 0x2000);\r\n\r\n      // Suspend audio processing before updating state shared with the ISR.\r\n      suspend();\r\n      v_bentPitch[voice] = pitch;\r\n      resume();\r\n    }\r\n  \r\n    uint8_t getAmp(uint8_t voice) {\r\n      return v_amp[voice];\r\n    }\r\n  \r\n    static uint16_t isr() __attribute__((always_inline)) {\r\n      _dac.begin();\r\n      TIMSK2 = 0;         // Disable timer2 interrupts to prevent reentrancy.\r\n      sei();              // Re-enable interrupts to ensure we do not miss MIDI events.\r\n    \r\n      {\r\n        static uint16_t noise = 0xACE1;                   // 16-bit maximal-period Galois LFSR\r\n        noise = (noise >> 1) ^ (-(noise & 1) & 0xB400);   // https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs\r\n      \r\n        static uint8_t divider = 0;                       // Time division is used to spread lower-frequency / periodic work\r\n        divider++;                                        // across interrupts.\r\n      \r\n        const uint8_t voice = divider & 0x0F;\t\t\t\t      // Bottom 4 bits of 'divider' selects which voice to perform work on.\r\n      \r\n        if (v_isNoise[voice]) {                           // To avoid needing a large wavetable for noise, we use xor to combine\r\n          v_xor[voice] = static_cast<uint8_t>(noise);     // the a 256B wavetable with samples from the LFSR.\r\n        }\r\n\r\n        const uint8_t fn = divider & 0xF0;                // Top 4 bits of 'divider' selects which additional work to perform.\r\n        switch (fn) {\r\n          case 0x00: {\t\t\t\t\t\t\t\t\t                  // Advance frequency modulation and update 'v_pitch' for the current voice.\r\n            int8_t freqMod = (v_freqMod[voice].sample() - 0x40);\r\n            v_pitch[voice] = v_bentPitch[voice] + freqMod;\r\n            break;\r\n          }\r\n        \r\n          case 0x50: {\t\t\t\t\t\t\t\t\t                  // Advance wave modulation and update 'v_wave' for the current voice.\r\n            int8_t waveMod = (v_waveMod[voice].sample());\r\n            v_wave[voice] = v_baseWave[voice] + waveMod;\r\n            break;\r\n          }\r\n\r\n          case 0xA0: {                                    // Advance the amplitude modulation and update 'v_amp' for the current voice.\r\n            uint16_t amp = v_ampMod[voice].sample();\r\n            v_amp[voice] = (amp * v_vol[voice]) >> 8;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Each interrupt, we transmit the previous output to the DAC concurrently with calculating\r\n      // the next wavOut.  This avoids unproductive busy-waiting for SPI to finish.\r\n      _dac.sendHiByte();\t\t\t\t\t\t\t\t\t\t// Begin transmitting upper 8-bits to DAC.\r\n\r\n      // Macro that advances '_phase[voice]' by the sampling interval '_pitch[voice]' and stores the next 8-bit\r\n      // sample offset as 'offset##voice'.\r\n      #define PHASE(voice) uint8_t offset##voice = ((v_phase[voice] += v_pitch[voice]) >> 8)\r\n\r\n      // Macro that samples the wavetable at the offset '_wave[voice] + offset##voice', and stores as 'sample##voice'.\r\n      #define SAMPLE(voice) int8_t sample##voice = (pgm_read_byte(v_wave[voice] + offset##voice))\r\n\r\n      // Macro that applies '_xor[voice]' to 'sample##voice' and multiplies by '_amp[voice]'.\r\n      #define MIX(voice) ((sample##voice ^ v_xor[voice]) * v_amp[voice])\r\n    \r\n      // We The below sampling/mixing code is carefully arranged to allow the compiler to make use of fixed\r\n      // offsets for loads and stores, and to leave temporary calculations in register.\r\n    \r\n      PHASE(0); PHASE(1); PHASE(2); PHASE(3);                             // Advance the Q8.8 phase and calculate the 8-bit offsets into the wavetable.\r\n      PHASE(4); PHASE(5); PHASE(6); PHASE(7);                             // (Load stores should use constant offsets and results should stay in register.)\r\n    \r\n      SAMPLE(0); SAMPLE(1); SAMPLE(2); SAMPLE(3);                         // Sample the wavetables at the offsets calculated above.\r\n      SAMPLE(4); SAMPLE(5); SAMPLE(6); SAMPLE(7);                         // (Samples should stay in register.)\r\n    \r\n      int16_t mix = (MIX(0) + MIX(1) + MIX(2) + MIX(3)) >> 1;             // Apply xor, modulate by amp, and mix.\r\n      mix += (MIX(4) + MIX(5) + MIX(6) + MIX(7)) >> 1;\r\n\r\n      _dac.sendLoByte();\t\t\t\t\t\t\t\t\t\t\t\t\t                        // Begin transmitting the lower 8-bits.\r\n\r\n      PHASE(8); PHASE(9); PHASE(10); PHASE(11);                           // Advance the Q8.8 phase and calculate the 8-bit offsets into the wavetable.\r\n      PHASE(12); PHASE(13); PHASE(14); PHASE(15);                         // (Load stores should use constant offsets and results should stay in register.)\r\n    \r\n      SAMPLE(8); SAMPLE(9); SAMPLE(10); SAMPLE(11);                       // Sample the wavetables at the offsets calculated above.\r\n      SAMPLE(12); SAMPLE(13); SAMPLE(14); SAMPLE(15);                     // (Samples should stay in register.)\r\n    \r\n      mix += (MIX(8) + MIX(9) + MIX(10) + MIX(11)) >> 1;                  // Apply xor, modulate by amp, and mix.\r\n      mix += (MIX(12) + MIX(13) + MIX(14) + MIX(15)) >> 1;\r\n\r\n      #undef MIX\r\n      #undef SAMPLE\r\n      #undef PHASE\r\n    \r\n      const uint16_t wavOut = mix + 0x8000;\r\n      _dac.set(wavOut);\t\t\t\t\t\t\t\t\t\t\t\t\t// Store resulting wave output for transmission on next interrupt.\r\n      _dac.end();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Clear SPIF flag to avoid confusing other SPI users when returning from interrupt.\r\n    \r\n      TIMSK2 = _BV(OCIE2A);                                               // Restore timer2 interrupts.\r\n    \r\n      return wavOut;\r\n    }\r\n\r\n  \r\n    // Suspends audio processing ISR.  While suspended, it is safe to update of volatile state\r\n    // shared with the ISR and to communicate with other SPI devices.\r\n    void suspend() __attribute__((always_inline)) {\r\n      cli();\r\n      TIMSK2 = 0;\r\n      sei();\r\n    }\r\n  \r\n    // Resumes audio processing ISR.\r\n    void resume() __attribute__((always_inline)) {\r\n      TIMSK2 = _BV(OCIE2A);\r\n    }\r\n  \r\n    #ifdef __EMSCRIPTEN__\r\n    Instrument instrument0;\r\n\r\n    void noteOnEm(uint8_t voice, uint8_t note, uint8_t velocity, uint8_t instrumentIndex) {\r\n      Instruments::getInstrument(instrumentIndex, instrument0);\r\n      this->noteOn(voice, note, velocity, instrument0);\r\n    }\r\n    #endif // __EMSCRIPTEN__\r\n};\r\n\r\nconstexpr uint16_t Synth::_noteToPitch[] PROGMEM;\t\t\t\t\t\t\t// Map MIDI notes [0..127] to the corresponding Q8.8 sampling interval\r\nconstexpr uint8_t Synth::offsetTable[];\r\nDAC Synth::_dac;\r\n\r\nvolatile const int8_t*  Synth::v_wave[Synth::numVoices]     = { 0 };\t// Starting address of 256b wave table.\r\nvolatile uint16_t       Synth::v_phase[Synth::numVoices]    = { 0 };\t// Phase accumulator holding the Q8.8 offset of the next sample.\r\nvolatile uint16_t       Synth::v_pitch[Synth::numVoices]    = { 0 };\t// Q8.8 sampling period, used to advance the '_phase' accumulator.\r\nvolatile int8_t         Synth::v_xor[Synth::numVoices]      = { 0 };\t// XOR bits applied to each sample (for effect).\r\nvolatile uint8_t        Synth::v_amp[Synth::numVoices]      = { 0 };\t// 6-bit amplitude scale applied to each sample.\r\nvolatile bool           Synth::v_isNoise[Synth::numVoices]  = { 0 };\t// If true, '_xor' is periodically overwritten with random values.\r\n\r\nvolatile Lerp           Synth::v_ampMod[Synth::numVoices]   = {};\t\t\t// Amplitude modulation\r\nvolatile Lerp           Synth::v_freqMod[Synth::numVoices]  = {};\t\t\t// Frequency modulation\r\nvolatile Lerp           Synth::v_waveMod[Synth::numVoices]  = {};\t\t\t// Wave offset modulation\r\n\r\nvolatile uint8_t        Synth::v_vol[Synth::numVoices]      = { 0 };\t// 7-bit volume scalar applied to ADSR output.\r\n\r\nvolatile uint16_t\t\tSynth::v_basePitch[Synth::numVoices]\t  = { 0 };\t// Original Q8.8 sampling period, prior to modulation, pitch bend, etc.\r\nvolatile uint16_t\t\tSynth::v_bentPitch[Synth::numVoices]\t  = { 0 };\t// Q8.8 sampling post pitch bend, but prior to freqMod.\r\nvolatile const int8_t*  Synth::v_baseWave[Synth::numVoices]\t= { 0 };  // Original starting address in wavetable.\r\nvolatile uint8_t\t\tSynth::_note[Synth::numVoices]\t\t\t    = { 0 };  // Index of '_basePitch' in the '_pitches' table, used for pitch bend calculation.\r\n\r\nSIGNAL(TIMER2_COMPA_vect) {\r\n  Synth::isr();\r\n}\r\n\r\n#endif // __SYNTH_H__","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/wire.h> requires building with -std=c++11 or newer!\n#else\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                    return &typeid(T);\n#else\n                    static_assert(!has_unbound_type_names,\n                        \"Unbound type names are illegal with RTTI disabled. \"\n                        \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                        \"from the compiler arguments\");\n                    static_assert(!std::is_polymorphic<C>::value,\n                        \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n                }\n\n                return CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                return &typeid(value);\n#else\n                static_assert(!has_unbound_type_names,\n                    \"Unbound type names are illegal with RTTI disabled. \"\n                    \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                    \"from the compiler arguments\");\n                static_assert(!std::is_polymorphic<C>::value,\n                    \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n            }\n            return LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n\n        template<typename T>\n        constexpr bool typeSupportsMemoryView() {\n            return (std::is_floating_point<T>::value &&\n                        (sizeof(T) == 4 || sizeof(T) == 8)) ||\n                    (std::is_integral<T>::value &&\n                        (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type of typed_memory_view is invalid\");\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n\n#endif // ~C++11 version check\n","#ifndef __LERP_H__\n#define __LERP_H__\n\n#include <stdint.h>\n#include \"instruments.h\"\n\nclass Lerp {\n  private:\n    const LerpStage* pStart = nullptr;\n    uint8_t loopStart = 0xFF;\n    uint8_t loopEnd = 0xFF;\n    uint8_t stageIndex = 0xFF;\n    int16_t amp = 0;\n    int16_t slope = 0;\n    int8_t limit = -128;\n  \n    void loadStage() volatile {\n      LerpStage stage;\n      Instruments::getLerpStage(pStart, stageIndex, stage);\n      slope = stage.slope;\n      limit = stage.limit;\n    }\n  \n  public:\n    uint8_t sample() volatile {\n      amp += slope;\n      int8_t out = amp >> 8;\n\n      const bool nextStage = (out < 0) ||\n        (slope <= 0)\n          ? out <= limit\n          : out >= limit;\n    \n      if (nextStage) {\n        out = limit;\n        amp = limit << 8;\n        stageIndex++;\n        if (stageIndex == loopEnd) {\n          stageIndex = loopStart;\n        }\n        loadStage();\n      }\n    \n      return out;\n    }\n  \n    void start(uint8_t programIndex) volatile {\n      LerpProgram program;\n      Instruments::getLerpProgram(programIndex, program);\n    \n      pStart = program.start;\n      loopStart = program.loopStartAndEnd >> 4;\n      loopEnd = program.loopStartAndEnd & 0x0F;\n      amp = program.initialValue << 8;\n      stageIndex = 0;\n    \n      loadStage();\n    }\n\n    void stop() volatile {\n      if (stageIndex < loopEnd) {\n        stageIndex = loopEnd;\n        loadStage();\n      }\n    }\n\n    friend class Synth;\n  \n  #ifdef __EMSCRIPTEN__\n    uint8_t sampleEm() { return sample(); }\n    void startEm(uint8_t program) { start(program); }\n    void stopEm() { stop(); }\n    uint8_t getStageIndex() { return stageIndex; }\n  #endif // __EMSCRIPTEN__\n};\n\n#endif //__LERP_H__","#ifndef __MIDISYNTH_H__\r\n#define __MIDISYNTH_H__\r\n\r\n#include <stdint.h>\r#include \"synth.h\"\r\n\r\nclass MidiSynth final : public Synth {\r\n  private:\r\n    constexpr static uint8_t numMidiChannels\t= 16;\t\t\t\t\t          // MIDI standard has 16 channels.\r    constexpr static uint8_t maxMidiChannel\t\t= numMidiChannels - 1;\t// Maximum channel is 15 when 0-indexed.\r    constexpr static uint8_t percussionChannel\t= 9;\t\t\t\t\t        // Channel 10 is percussion (9 when 0-indexed).\r\r\n    uint8_t voiceToNote[numVoices];\t\t\t\t\t\t\t        // Map synth voice to the current MIDI note (or 0xFF if off).\r    uint8_t voiceToChannel[numVoices];\t\t\t\t\t\t      // Map synth voice to the current MIDI channel (or 0xFF if off).\r    Instrument channelToInstrument[numMidiChannels];\t\t// Map MIDI channel to the current MIDI program (i.e., instrument).\r\n\r\n  public:\r    MidiSynth() : Synth() {\r      for (int8_t channel = maxMidiChannel; channel >= 0; channel--) {\r        Instruments::getInstrument(0, channelToInstrument[channel]);\r      }\r\r\n      for (int8_t channel = maxMidiChannel; channel >= 0; channel--) {\r        voiceToNote[channel] = 0xFF;\r        voiceToChannel[channel] = 0xFF;\r      }\r    }\r\r\n    void midiNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {\r      if (channel == percussionChannel) {\t\t\t\t\t\t    // If playing the percussion channel\r        note = Instruments::getPercussiveInstrument(    //   Update the channel instrument for the given note, and\r          note, channelToInstrument[channel]);          //   replace the note with the correct playback frequency\r      }                                                 //   for the instrument (expressed as a midi note).\r\r\n      uint8_t voice = getNextVoice();\t\t\t\t\t\t\t\t\t  // Find an available voice and play the note.\r      noteOn(voice, note, velocity, channelToInstrument[channel]);\r\r\n      voiceToNote[voice] = note;\t\t\t\t\t\t\t\t        // Update our voice -> note/channel maps (used for processing MIDI\r      voiceToChannel[voice] = channel;\t\t\t\t\t\t      // pitch bend and note off messages).\r    }\r\r\n    void midiNoteOff(uint8_t channel, uint8_t note)  {\r      for (int8_t voice = maxVoice; voice >= 0; voice--) {\t\t\t\t\t\t          // For each voice\r        if (voiceToNote[voice] == note && voiceToChannel[voice] == channel) {   //   that is currently playing the note on this channel\r          noteOff(voice);\t\t\t\t\t\t\t\t\t\t\t\t\t\t                            //      stop playing the note\r          voiceToChannel[voice] = 0xFF;\t\t\t\t\t\t\t\t\t\t                      //      and remove the voice from our voice -> note/channel\r          voiceToNote[voice] = 0xFF;\t\t\t\t\t\t\t\t\t\t\t                      //      maps so we ignore it for future node off / pitch bench\r        }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                    //      messages.\r      }\r    }\r\r\n    void midiProgramChange(uint8_t channel, uint8_t program) {\r      Instruments::getInstrument(program, channelToInstrument[channel]);\t\t\t  // Load the instrument corresponding to the given MIDI program\r    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                    // into the MIDI channel -> instrument map.\r\r\n    void midiPitchBend(uint8_t channel, int16_t value) {\r      for (int8_t voice = maxVoice; voice >= 0; voice--) {\t\t\t\t\t\t// For each voice\r        if (voiceToChannel[voice] == channel) {\t\t\t\t\t\t\t\t\t      //   which is currently playing a note on this channel\r          pitchBend(voice, value);\t\t\t\t\t\t\t\t\t\t\t              //     update pitch bench with the given value.\r        }\r      }\r    }\r  \r    void midiControlChange(uint8_t channel, uint8_t controller, uint8_t value) {\r      switch (controller) {\r\n        case 0x7B: {\r\n          switch (value) {\r\n            // All Notes Off (for current channel):\r\n            case 0: {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                      \r\n              for (int8_t voice = maxVoice; voice >= 0; voice--) {\t\t\t// For each voice\r                if (voiceToChannel[voice] == channel) {\t\t\t\t\t\t      //   currently playing any note on this channel\r                  noteOff(voice);\t\t\t\t\t\t\t\t\t\t\t                  //\t   stop playing the note\r                  voiceToChannel[voice] = 0xFF;\t\t\t\t\t\t\t            //      and remove the voice from our voice -> note/channel\r                  voiceToNote[voice] = 0xFF;\t\t\t\t\t\t\t\t            //      maps so we ignore it for future node off / pitch bench\r                }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                          //      messages.\r              }\r              break;\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r}; //MidiSynth\r\n\r\n#endif //__MIDISYNTH_H__\r\n","#ifndef PGMSPACE_H_\n#define PGMSPACE_H_\n\n#include <stdint.h>\n#include <string.h>\n\n#define PROGMEM\n\nuint8_t pgm_read_byte(const volatile void* ptr);\nuint16_t pgm_read_word(const volatile void* ptr);\n\n#define memcpy_P memcpy\n\ntemplate<typename T>\r\nstruct HeapRegion {\r\n  size_t start;\r\n  size_t end;\r\n  size_t itemSize;\r\n\r\n  HeapRegion() {}\r\n  \r\n  HeapRegion(const T* pStart, const size_t length) {\r\n    start = reinterpret_cast<size_t>(pStart);\r\n    end = start + length;\r\n    itemSize = sizeof(T);\r\n  }\r\n};\n\n#endif /* PGMSPACE_H_ */","#ifndef LTC16XX_H_\r\n#define LTC16XX_H_\r\n\r\n#include \"../spi.h\"\r\n\r\ntemplate<PinId csPin>\r\nclass Ltc16xx final {\r\n  private:\r\n    uint16_t out;\r\n    Spi<csPin> _spi;\r\n  \r\n  public:\r\n    void setup() { _spi.setup(); }\r\n  \r\n    void set(uint16_t value) {\r\n      out = value;\r\n    }\r\n\r\n    void begin() { }\r\n  \r\n    void sendHiByte() {\r\n      _spi.begin();\r\n      _spi.unsafe_send(out >> 8);\r\n    }\r\n  \r\n    void sendLoByte() {\r\n      _spi.unsafe_send(out);\r\n    }\r\n\r\n    void end() {\r\n      _spi.end();\r\n      _spi.unsafe_clearEndOfTransmissionFlag();\r\n    }\r\n};\r\n\r\n#endif /* LTC16XX_H_ */","#ifndef PINS_H_\r\n#define PINS_H_\r\n\r\n#include <avr/io.h>\r\n\r\nenum class PinId {\r\n  D0 = 0,\r\n  D1 = 1,\r\n  D2 = 2,\r\n  D3 = 3,\r\n  D4 = 4,\r\n  D5 = 5,\r\n  D6 = 6,\r\n  D7 = 7,\r\n  D8 = 8,\r\n  D9 = 9,\r\n  D10 = 10,\r\n  D11 = 11,\r\n  D12 = 12,\r\n  D13 = 13,\r\n  A0 = 14,\r\n  A1 = 15,\r\n  A2 = 16,\r\n  A3 = 17,\r\n  A4 = 18,\r\n  A5 = 19,\r\n};\r\n\r\ntemplate<PinId pin>\r\nclass Pin {\r\n  public:\r\n    void output() __attribute__((always_inline)) {\r\n      switch (pin) {\r\n        // PortD\r\n        case PinId::D0: DDRD |= _BV(DDD0); break;\r\n        case PinId::D1: DDRD |= _BV(DDD1); break;\r\n        case PinId::D2: DDRD |= _BV(DDD2); break;\r\n        case PinId::D3: DDRD |= _BV(DDD3); break;\r\n        case PinId::D4: DDRD |= _BV(DDD4); break;\r\n        case PinId::D5: DDRD |= _BV(DDD5); break;\r\n        case PinId::D6: DDRD |= _BV(DDD6); break;\r\n        case PinId::D7: DDRD |= _BV(DDD7); break;\r\n\r\n        // DDRB\r\n        case PinId::D8: DDRB |= _BV(DDB0); break;\r\n        case PinId::D9: DDRB |= _BV(DDB1); break;\r\n        case PinId::D10: DDRB |= _BV(DDB2); break;\r\n        case PinId::D11: DDRB |= _BV(DDB3); break;\r\n        case PinId::D12: DDRB |= _BV(DDB4); break;\r\n        case PinId::D13: DDRB |= _BV(DDB5); break;\r\n\r\n        // DDRC\r\n        case PinId::A0: DDRC |= _BV(DDC0); break;\r\n        case PinId::A1: DDRC |= _BV(DDC1); break;\r\n        case PinId::A2: DDRC |= _BV(DDC2); break;\r\n        case PinId::A3: DDRC |= _BV(DDC3); break;\r\n        case PinId::A4: DDRC |= _BV(DDC4); break;\r\n        case PinId::A5: DDRC |= _BV(DDC5); break;\r\n      }\r\n    }\r\n\r\n    void high() __attribute__((always_inline)) {\r\n      switch (pin) {\r\n        // PortD\r\n        case PinId::D0: PORTD |= _BV(PORTD0); break;\r\n        case PinId::D1: PORTD |= _BV(PORTD1); break;\r\n        case PinId::D2: PORTD |= _BV(PORTD2); break;\r\n        case PinId::D3: PORTD |= _BV(PORTD3); break;\r\n        case PinId::D4: PORTD |= _BV(PORTD4); break;\r\n        case PinId::D5: PORTD |= _BV(PORTD5); break;\r\n        case PinId::D6: PORTD |= _BV(PORTD6); break;\r\n        case PinId::D7: PORTD |= _BV(PORTD7); break;\r\n\r\n        // PortB\r\n        case PinId::D8: PORTB |= _BV(PORTB0); break;\r\n        case PinId::D9: PORTB |= _BV(PORTB1); break;\r\n        case PinId::D10: PORTB |= _BV(PORTB2); break;\r\n        case PinId::D11: PORTB |= _BV(PORTB3); break;\r\n        case PinId::D12: PORTB |= _BV(PORTB4); break;\r\n        case PinId::D13: PORTB |= _BV(PORTB5); break;\r\n\r\n        // PortC\r\n        case PinId::A0: PORTC |= _BV(PORTC0); break;\r\n        case PinId::A1: PORTC |= _BV(PORTC1); break;\r\n        case PinId::A2: PORTC |= _BV(PORTC2); break;\r\n        case PinId::A3: PORTC |= _BV(PORTC3); break;\r\n        case PinId::A4: PORTC |= _BV(PORTC4); break;\r\n        case PinId::A5: PORTC |= _BV(PORTC5); break;\r\n      }\r\n    }\r\n\r\n    void low() __attribute__((always_inline)) {\r\n      switch (pin) {\r\n        // PortD\r\n        case PinId::D0: PORTD &= ~_BV(PORTD0); break;\r\n        case PinId::D1: PORTD &= ~_BV(PORTD1); break;\r\n        case PinId::D2: PORTD &= ~_BV(PORTD2); break;\r\n        case PinId::D3: PORTD &= ~_BV(PORTD3); break;\r\n        case PinId::D4: PORTD &= ~_BV(PORTD4); break;\r\n        case PinId::D5: PORTD &= ~_BV(PORTD5); break;\r\n        case PinId::D6: PORTD &= ~_BV(PORTD6); break;\r\n        case PinId::D7: PORTD &= ~_BV(PORTD7); break;\r\n\r\n        // PortB\r\n        case PinId::D8: PORTB &= ~_BV(PORTB0); break;\r\n        case PinId::D9: PORTB &= ~_BV(PORTB1); break;\r\n        case PinId::D10: PORTB &= ~_BV(PORTB2); break;\r\n        case PinId::D11: PORTB &= ~_BV(PORTB3); break;\r\n        case PinId::D12: PORTB &= ~_BV(PORTB4); break;\r\n        case PinId::D13: PORTB &= ~_BV(PORTB5); break;\r\n\r\n        // PortC\r\n        case PinId::A0: PORTC &= ~_BV(PORTC0); break;\r\n        case PinId::A1: PORTC &= ~_BV(PORTC1); break;\r\n        case PinId::A2: PORTC &= ~_BV(PORTC2); break;\r\n        case PinId::A3: PORTC &= ~_BV(PORTC3); break;\r\n        case PinId::A4: PORTC &= ~_BV(PORTC4); break;\r\n        case PinId::A5: PORTC &= ~_BV(PORTC5); break;\r\n      }\r\n    }\r\n};\r\n\r\n#endif /* PINS_H_ */\r\n","#ifndef SPI_H_\r\n#define SPI_H_\r\n\r\n#include \"pin.h\"\r\n\r\ntemplate<PinId csPin>\r\nclass Spi final {\r\n  private:\r\n    Pin<csPin> _csPin;\r\n  \r\n  public:\r\n    void setup() {\r\n      _csPin.high();\r\n      _csPin.output();\r\n    \r\n      SPSR |= _BV(SPI2X);                 // SCK = F_CPU/2\r\n      SPCR = _BV(SPE) | _BV(MSTR);        // Enable SPI, Master\r\n    \r\n      // Note: We must set the default CS pin as an output, even if we're using a different\r\n      //       pin to select the device.  (TODO: Verify?)\r\n      DDRB |= _BV(DDB5) | _BV(DDB3) | _BV(DDB2);\t// Set MOSI, SCK, and CS as outputs after enabling SPI.\r\n    }\r\n  \r\n    void begin() {\r\n      _csPin.low();\r\n    }\r\n  \r\n    void end() {\r\n      _csPin.high();\r\n    }\r\n  \r\n    void flush() __attribute__((always_inline)) {\n      while (!(SPSR & _BV(SPIF)));\n    }\n  \n    void unsafe_clearEndOfTransmissionFlag() __attribute__((always_inline)) {\n    #ifdef __EMSCRIPTEN__\n      #pragma clang diagnostic push\r\n      #pragma clang diagnostic ignored \"-Wunused-value\"\r\n    #endif\r\n      SPSR;\r\n    #ifdef __EMSCRIPTEN__\n      #pragma clang diagnostic pop\n    #endif\r\n    }\n  \r\n    void unsafe_send(uint8_t data) __attribute__((always_inline)) {\n      SPDR = data;\n    }\n  \r\n    void send(const uint8_t data) __attribute__((always_inline)) {\n      unsafe_send(data);\n      flush();\n    }\n};\r\n\r\n#endif /* SPI_H_ */","#include <emscripten/bind.h>\n#ifdef USE_CXA_DEMANGLE\n#include <../lib/libcxxabi/include/cxxabi.h>\n#endif\n#include <list>\n#include <vector>\n#include <typeinfo>\n#include <algorithm>\n#include <emscripten/emscripten.h>\n#include <emscripten/wire.h>\n#include <climits>\n#include <limits>\n\nusing namespace emscripten;\n\nextern \"C\" {\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\n        if (has_unbound_type_names) {\n#ifdef USE_CXA_DEMANGLE\n            int stat;\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\n            if (stat == 0 && demangled) {\n                return demangled;\n            }\n\n            switch (stat) {\n                case -1:\n                    return strdup(\"<allocation failure>\");\n                case -2:\n                    return strdup(\"<invalid C++ symbol>\");\n                case -3:\n                    return strdup(\"<invalid argument>\");\n                default:\n                    return strdup(\"<unknown error>\");\n            }\n#else\n            return strdup(ti->name());\n#endif\n        } else {\n            char str[80];\n            sprintf(str, \"%p\", reinterpret_cast<const void*>(ti));\n            return strdup(str);\n        }\n    }\n}\n\nnamespace {\n    template<typename T>\n    static void register_integer(const char* name) {\n        using namespace internal;\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\n    }\n\n    template<typename T>\n    static void register_float(const char* name) {\n        using namespace internal;\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\n    }\n\n\n    // matches typeMapping in embind.js\n    enum TypedArrayIndex {\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n    };\n\n    template<typename T>\n    constexpr TypedArrayIndex getTypedArrayIndex() {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type does not map to a typed array\");\n        return std::is_floating_point<T>::value\n            ? (sizeof(T) == 4\n               ? Float32Array\n               : Float64Array)\n            : (sizeof(T) == 1\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\n               : (sizeof(T) == 2\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\n    }\n\n    template<typename T>\n    static void register_memory_view(const char* name) {\n        using namespace internal;\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\n    }\n}\n\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\n    using namespace emscripten::internal;\n\n    _embind_register_void(TypeID<void>::get(), \"void\");\n\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\n\n    register_integer<char>(\"char\");\n    register_integer<signed char>(\"signed char\");\n    register_integer<unsigned char>(\"unsigned char\");\n    register_integer<signed short>(\"short\");\n    register_integer<unsigned short>(\"unsigned short\");\n    register_integer<signed int>(\"int\");\n    register_integer<unsigned int>(\"unsigned int\");\n    register_integer<signed long>(\"long\");\n    register_integer<unsigned long>(\"unsigned long\");\n\n    register_float<float>(\"float\");\n    register_float<double>(\"double\");\n\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\n\n    // Some of these types are aliases for each other. Luckily,\n    // embind.js's _embind_register_memory_view ignores duplicate\n    // registrations rather than asserting, so the first\n    // register_memory_view call for a particular type will take\n    // precedence.\n\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\n\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\n\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\n\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\n#if __SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\n#endif\n}\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\nprotected:\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n"]}